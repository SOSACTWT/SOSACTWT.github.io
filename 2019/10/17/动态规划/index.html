<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>动态规划 | 大呓纪</title><meta name="description" content="数塔最大路径和 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&#x2F;&#x2F;数塔&#x2F;* 时间复杂度：O(n^2) *&#x2F;#include&lt;iostream&gt;using namespace std;const int m"><meta name="keywords" content="动态规划"><meta name="author" content="江城子"><meta name="copyright" content="江城子"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="http://yoursite.com/2019/10/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="yandex-verification" content="{&quot;theme_color&quot;:{&quot;enable&quot;:true,&quot;main&quot;:&quot;#49B1F5&quot;}}"/><meta property="og:type" content="article"><meta property="og:title" content="动态规划"><meta property="og:url" content="http://yoursite.com/2019/10/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><meta property="og:site_name" content="大呓纪"><meta property="og:description" content="数塔最大路径和 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&#x2F;&#x2F;数塔&#x2F;* 时间复杂度：O(n^2) *&#x2F;#include&lt;iostream&gt;using namespace std;const int m"><meta property="og:image" content="http://yoursite.com/2019/10/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/cover.jpg"><meta property="article:published_time" content="2019-10-17T15:24:58.000Z"><meta property="article:modified_time" content="2021-02-25T14:08:06.695Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.0.2',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2021-02-25 22:08:06'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 5.0.2"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">11</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">13</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 基地</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 类别</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E5%A1%94%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-number">1.</span> <span class="toc-text">数塔最大路径和</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%92%8C%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">2.</span> <span class="toc-text">最大和连续子序列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E4%B8%8D%E4%B8%8B%E9%99%8D%E5%AD%90%E5%BA%8F%E5%88%97-%E5%8F%AF%E4%BB%A5%E4%B8%8D%E8%BF%9E%E7%BB%AD"><span class="toc-number">3.</span> <span class="toc-text">最长不下降子序列(可以不连续)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">4.</span> <span class="toc-text">最长公共子序列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="toc-number">5.</span> <span class="toc-text">最小编辑距离</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%B0%91%E7%A1%AC%E5%B8%81%E5%85%91%E6%8D%A2%E9%97%AE%E9%A2%98"><span class="toc-number">6.</span> <span class="toc-text">最少硬币兑换问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-number">7.</span> <span class="toc-text">最长回文子串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#01%E8%83%8C%E5%8C%85"><span class="toc-number">8.</span> <span class="toc-text">01背包</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(/2019/10/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/top_img.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">大呓纪</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 基地</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 类别</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">动态规划</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2019-10-17T15:24:58.000Z" title="undefined 2019-10-17 23:24:58">2019-10-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>29分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="数塔最大路径和"><a href="#数塔最大路径和" class="headerlink" title="数塔最大路径和"></a>数塔最大路径和</h1><p><img src= "/img/loading.gif" data-lazy-src="/2019/10/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%95%B0%E5%A1%94.jpg" alt="数塔"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数塔</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 时间复杂度：O(n^2)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn],dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create_Tower</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;f[i][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//构建数塔</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Display_Tower</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Tower:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;f[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//打印数塔</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxSumofPath_in_Tower</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="comment">//自底层而上，计算每个节点f[i][j]到最后一层的路径上可能的路径和,记为dp[i][j]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">        dp[n][j] = f[n][j];</span><br><span class="line">    &#125;<span class="comment">//最后一排的记为自身</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            dp[i][j]=<span class="built_in">max</span>(dp[i+<span class="number">1</span>][j],dp[i+<span class="number">1</span>][j+<span class="number">1</span>]) + f[i][j];<span class="comment">//dp[i][j]为下一层与其邻接的两个结点中的最大值+f[i][j]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">1</span>][<span class="number">1</span>];<span class="comment">//自下而上直到第一层，最后便能得到最大路径和了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    Create_Tower(n);</span><br><span class="line">    Display_Tower(n);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;maxsum: &quot;</span>&lt;&lt;MaxSumofPath_in_Tower(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> input:</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">8 3</span></span><br><span class="line"><span class="comment">12 7 16</span></span><br><span class="line"><span class="comment">4 10 11 6</span></span><br><span class="line"><span class="comment">9 5 3 9 4</span></span><br><span class="line"><span class="comment"> output:</span></span><br><span class="line"><span class="comment">Tower:</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">8 3</span></span><br><span class="line"><span class="comment">12 7 16</span></span><br><span class="line"><span class="comment">4 10 11 6</span></span><br><span class="line"><span class="comment">9 5 3 9 4</span></span><br><span class="line"><span class="comment">maxsum: 44</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h1 id="最大和连续子序列"><a href="#最大和连续子序列" class="headerlink" title="最大和连续子序列"></a>最大和连续子序列</h1><p>对最大下标n的序列<br> 要求最大和连续子序列，<br> 这个子序列可能是以A[i]开始，A[n]结尾的某个序列，<br> 也可能是整个序列中间的某个连续子序列，即之前n-1个元素的序列的解，它也必然是以某个元素结尾的序列<br> 因此问题转化为求以各个元素为结尾的子序列的最大和，最后取其中最大的即可。<br> 具体来说：<br> 现在把dp数组考虑为dp[i]为以i结尾的序列的最大和,则dp[i]要么是单个元素A[i]，要么是A[i]+以A[i-1]为结尾的最大和<br> 即，dp[i]=max{dp[i-1]+A[i],A[i]}<br> 那么最终整个序列中的最大序列和就是dp数组中的最大值</p>
<p> 时间复杂度：O(n)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputA</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> *A)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;A[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OutputA</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> *A)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;A[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OutputDp</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> *dp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;dp[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxSUM</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> *A)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *dp = <span class="keyword">new</span> <span class="keyword">int</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        dp[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>] = A[<span class="number">0</span>];<span class="comment">//以A[0]结尾的最大和即它本身</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        dp[i]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>]+A[i],A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxsum=dp[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i]&gt;maxsum)&#123;</span><br><span class="line">            maxsum=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    OutputDp(n,dp);</span><br><span class="line">    <span class="keyword">return</span> maxsum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> *A  =<span class="keyword">new</span> <span class="keyword">int</span>(n);</span><br><span class="line"></span><br><span class="line">    InputA(n,A);</span><br><span class="line">    OutputA(n,A);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;MaxSUM(n,A)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">input:</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">-2 11 -4 13 -5 -2</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">-2 11 -4 13 -5 -2 </span></span><br><span class="line"><span class="comment">-2 11 7 20 15 13 </span></span><br><span class="line"><span class="comment">20</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h1 id="最长不下降子序列-可以不连续"><a href="#最长不下降子序列-可以不连续" class="headerlink" title="最长不下降子序列(可以不连续)"></a>最长不下降子序列(可以不连续)</h1><p>一每个元素结尾的序列，其最长度至少为1，故初始化dp[i]皆为1，<br> 对于一个A[i]来说，以他结尾的最长不下降子序列，可以这样找：<br> 从他开始往前找找，找到前面子序列中(遍历0～i-1)不大于它的元素A[j]并且能有dp[j]+1&gt;dp[i]，则不断更新dp[i]=dp[j]+1;<br> 找不到的话自然dp[i]还是1，即最长为他自身。<br> 时间复杂度：O(n^2)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最长不下降子序列(可以不连续)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 一每个元素结尾的序列，其最长度至少为1，故初始化dp[i]皆为1，</span></span><br><span class="line"><span class="comment"> 对于一个A[i]来说，以他结尾的最长不下降子序列，可以这样找：</span></span><br><span class="line"><span class="comment"> 从他开始往前找找，找到前面子序列中(遍历0～i-1)不大于它的元素A[j]并且能有dp[i]&gt;dp[j]+1，则不断更新dp[i]=dp[j]+1;</span></span><br><span class="line"><span class="comment"> 找不到的话自然dp[i]还是1，即最长为他自身。</span></span><br><span class="line"><span class="comment"> 时间复杂度：O(n^2)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> A[maxn],dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Input_A</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;A[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Output_dp</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;dp: &quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;dp[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LIS</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[j]&lt;=A[i]&amp;&amp;(dp[j]+<span class="number">1</span>&gt;dp[i]))&#123;</span><br><span class="line">                dp[i] = dp[j]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//转移</span></span><br><span class="line">    <span class="keyword">int</span> maxlength=dp[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i]&gt;maxlength)&#123;</span><br><span class="line">            maxlength = dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxlength;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    Input_A(n);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;maxlength: &quot;</span>&lt;&lt;LIS(n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    Output_dp(n);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Input：</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">1 2 3 -1 -2 7 9</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">maxlength: 5</span></span><br><span class="line"><span class="comment">dp:</span></span><br><span class="line"><span class="comment">1 2 3 1 1 4 5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">input:</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">1 2 3 -9 3 9 0 11</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">maxlength: 6</span></span><br><span class="line"><span class="comment">dp:</span></span><br><span class="line"><span class="comment">1 2 3 1 4 5 2 6</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h1 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最长公共子序列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">定义dp[][],dp[i][0]=dp[0][j]=0,可以表示字母与空集的最长公共子序列为0；dp[0][0]自然是空对空公共序列为空了。</span></span><br><span class="line"><span class="comment"> 那么每个序列的正式下标自然从1开始了，dp[i][j]表示A的前i个元素与B的前j个元素的最长公共子序列大小。</span></span><br><span class="line"><span class="comment"> 时间复杂度：O(n^2)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCS</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *A, <span class="keyword">const</span> <span class="keyword">char</span> *B, <span class="keyword">int</span> lena, <span class="keyword">int</span> lenb)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length_LCS=<span class="built_in">min</span>(lena,lenb),count=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> LCS[length_LCS+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> **dp= <span class="keyword">new</span> <span class="keyword">int</span>*[lena+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lena+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        dp[i] =<span class="keyword">new</span> <span class="keyword">int</span>[lenb+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=lena;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=lenb;i++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lena;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=lenb;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]==B[j]) dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=lena;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=lenb;j++)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;dp[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="comment">//打印dp</span></span><br><span class="line">    <span class="keyword">int</span> i=lena,j=lenb;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;dp[i][j]&lt;&lt;A[i]&lt;&lt;endl&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">while</span>(dp[i][j])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i][j] == dp[i<span class="number">-1</span>][j]) i--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dp[i][j] == dp[i][j<span class="number">-1</span>]) j--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dp[i][j]&gt;dp[i<span class="number">-1</span>][j<span class="number">-1</span>])&#123;</span><br><span class="line">            LCS[++count] =A[i];</span><br><span class="line">            <span class="comment">//cout&lt;&lt;A[i]&lt;&lt;endl&lt;&lt;endl;</span></span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//推出一条最长公共子序列</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;LCS: &quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=count;k&gt;=<span class="number">0</span>;k--)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;LCS[k]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;<span class="comment">//打印最长公共子序列</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> dp[lena][lenb];<span class="comment">//返回最长公共子序列长度                 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lena,lenb;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;lena;</span><br><span class="line">    <span class="keyword">char</span> A[lena+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lena;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;lenb;</span><br><span class="line">    <span class="keyword">char</span> B[lenb+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lenb;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> length_of_LCS=LCS(A,B,lena,lenb);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;length of LCS: &quot;</span>&lt;&lt;length_of_LCS;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">input:</span></span><br><span class="line"><span class="comment"> 8</span></span><br><span class="line"><span class="comment">sadstory</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">adminsorry</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">0 0 0 0 0 0 1 1 1 1 1</span></span><br><span class="line"><span class="comment">0 1 1 1 1 1 1 1 1 1 1</span></span><br><span class="line"><span class="comment">0 1 2 2 2 2 2 2 2 2 2</span></span><br><span class="line"><span class="comment">0 1 2 2 2 2 3 3 3 3 3</span></span><br><span class="line"><span class="comment">0 1 2 2 2 2 3 3 3 3 3</span></span><br><span class="line"><span class="comment">0 1 2 2 2 2 3 4 4 4 4</span></span><br><span class="line"><span class="comment">0 1 2 2 2 2 3 4 5 5 5</span></span><br><span class="line"><span class="comment">0 1 2 2 2 2 3 4 5 5 6</span></span><br><span class="line"><span class="comment">LCS:</span></span><br><span class="line"><span class="comment">a d s o r y</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h1 id="最小编辑距离"><a href="#最小编辑距离" class="headerlink" title="最小编辑距离"></a>最小编辑距离</h1><p>编辑距离问题就是问把一个单词变成另一个单词最少需要多少步操作（插入，删除，替换）<br> 时间复杂度：O(n^2)</p>
<p>（*）这段主要是讨论根据哪一个编辑距离来计算A到A[i]为止和和B中到B[j]为止的两段序列的编辑距离dp[i] [j]我们希望编辑距离自然是越小越好</p>
<p>拿dp[i-1] [j]来说，若用它来算dp[i] [j],由于dp[i-1] [j]确定了，则现在由于新加入了一个A[i]，故必然要多一次操作，即dp[i] [j]=dp[i-1] [j]+1;<br>选到dp[i] [j-1]算dp[i] [j]也是同理，故我们选他俩中小的操作，即希望最后得到的编辑距离能尽可能小</p>
<p>而若我们是拿dp[i-1] [j-1]来算dp[i] [j]，即A和B都新放了一个元素，即A[i]和B[j]，那就需要讨论了<br>        1.若A[i]=B[j]，则新加入的这俩元素不需要修改，对编辑距离没有影响，故dp[i] [j] = dp[i-1] [j-1]<br>        2.而若A[i]！=B[j]，则在dp[i] [j]的基础上，把A[i]改成B[i]或是把B[i]改成A[i]即可，                                                             故dp[i] [j] = dp[i-1] [j-1]+1;<br>        我们把两种情况综合一下，即基于dp[i-1] [j-1]，A[i]和B[j]等,则不动；不等则动一下（即加1），</p>
<p>​        因此我们添加一个变量I，I = (A[i]!=B[j])?1:0; 得dp[i] [j] = dp[i-1] [j-1]+I</p>
<p>故综上所述，就有了dp[i] [j]=min{dp[i-1] [j]+1 , dp[i] [j-1]+1 , dp[i-1] [j-1]+I}</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编辑距离问题</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 编辑距离问题就是问把一个单词变成另一个单词最少需要多少步操作（插入，删除，替换）</span></span><br><span class="line"><span class="comment"> 时间复杂度：O(n^2)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_dp</span><span class="params">(<span class="keyword">int</span> **dp,<span class="keyword">int</span> lena,<span class="keyword">int</span> lenb)</span></span>&#123;<span class="comment">//dp的形状为（lena+1）x(lenb+1)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=lena;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;<span class="comment">//与下面相反，即做i次删除操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=lenb;i++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = i;</span><br><span class="line">    &#125;<span class="comment">//长度为0的单词变为长度为i的单词操作自然是插入i此</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print_dp</span><span class="params">(<span class="keyword">int</span> **dp,<span class="keyword">int</span> lena,<span class="keyword">int</span> lenb)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=lena;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=lenb;j++)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;dp[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="comment">//打印dp矩阵</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EditDistance</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *A, <span class="keyword">const</span> <span class="keyword">char</span> *B, <span class="keyword">int</span> lena, <span class="keyword">int</span> lenb)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> **dp= <span class="keyword">new</span> <span class="keyword">int</span>*[lena+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lena+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        dp[i] =<span class="keyword">new</span> <span class="keyword">int</span>[lenb+<span class="number">1</span>];</span><br><span class="line">    &#125;<span class="comment">//构建dp数组</span></span><br><span class="line">    Init_dp(dp,lena,lenb);<span class="comment">//初始化dp数组</span></span><br><span class="line">    <span class="keyword">int</span> I=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lena;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=lenb;j++)&#123;</span><br><span class="line">            I = (A[i]!=B[j])?<span class="number">1</span>:<span class="number">0</span>;<span class="comment">//即A[i]!=B[i],则I=1，多一位需要修改的元素；</span></span><br><span class="line">                                 <span class="comment">//A[i]=B[i],则I=0，则这位元素我需修改</span></span><br><span class="line">            dp[i][j]=<span class="built_in">min</span>( <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j]+<span class="number">1</span>,dp[i][j<span class="number">-1</span>]+<span class="number">1</span>)  ,  dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+I);</span><br><span class="line">        &#125;<span class="comment">//看上面（*）处的解释</span></span><br><span class="line">    &#125;</span><br><span class="line">    Print_dp(dp,lena,lenb);</span><br><span class="line">    <span class="keyword">return</span> dp[lena][lenb];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lena,lenb;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;lena;</span><br><span class="line">    <span class="keyword">char</span> A[lena+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//gets(A+1);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lena;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;lenb;</span><br><span class="line">    <span class="keyword">char</span> B[lenb+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lenb;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;EditDistance(A,B,lena,lenb);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">input:</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">ALTRUISTIC</span></span><br><span class="line"><span class="comment">9</span></span><br><span class="line"><span class="comment">ALGORITHM</span></span><br><span class="line"><span class="comment">output</span></span><br><span class="line"><span class="comment">0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"><span class="comment">1 0 1 2 3 4 5 6 7 8</span></span><br><span class="line"><span class="comment">2 1 0 1 2 3 4 5 6 7</span></span><br><span class="line"><span class="comment">3 2 1 1 2 3 4 4 5 6</span></span><br><span class="line"><span class="comment">4 3 2 2 2 2 3 4 5 6</span></span><br><span class="line"><span class="comment">5 4 3 3 3 3 3 4 5 6</span></span><br><span class="line"><span class="comment">6 5 4 4 4 4 3 4 5 6</span></span><br><span class="line"><span class="comment">7 6 5 5 5 5 4 4 5 6</span></span><br><span class="line"><span class="comment">8 7 6 6 6 6 5 4 5 6</span></span><br><span class="line"><span class="comment">9 8 7 7 7 7 6 5 5 6</span></span><br><span class="line"><span class="comment">10 9 8 8 8 8 7 6 6 6</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h1 id="最少硬币兑换问题"><a href="#最少硬币兑换问题" class="headerlink" title="最少硬币兑换问题"></a>最少硬币兑换问题</h1><p>输入：<br>给定n种面值的硬币，d1=1，d1&lt;d2&lt;d3&lt;d4&lt;…..&lt;dn，<br>硬币数量不限<br>输出：<br>最少用多少个硬币可以兑换金额N<br>时间/空间复杂度：O(nN)</p>
<p>想法：</p>
<p>当我们现在有了d[1]~d[i]，需要兑换的金额为j</p>
<p>此时有两种可能：</p>
<ul>
<li><p>我们不用d[i]，只用d[1]~d[i-1]兑换出N来，</p>
<p>如有1，2，5或1，2都可以把4、6给兑换出来</p>
<p>那我们所需的硬币数量即dp[i-1] [j]，即dp[i] [j] = dp[i-1] [j]；</p>
</li>
<li><p>用到至少一个d[i]，那么dp[i] [j] = dp[i] [j-d[i]]+1</p>
<p>如我们要用1 2 5兑换8块，8-5=3，我们用1 2 5兑换3块时需要2个币，                                                           现再加上一个5块的即可，即2+1=3个币。</p>
</li>
</ul>
<p>由此我们只要看哪种方法用的硬币少就用哪种方法。</p>
<p>即：dp[i] [j] = min(dp[i-1] [j]，dp[i] [j-d[i]]+1);🍎</p>
<p>这里有个需要注意的问题时：j-d[i]可能小于0，如想用1 2 5兑换3块，3-5 = -2，本意是想用1 2 5兑换-2块的硬币数量再加上一个五块硬币🪙即可，但去兑换 -2 块这显然不对，这就说明我们兑换3块钱时压根本没法用上5块的硬币。</p>
<p>因此我们对上面👆🍎处min()的第二项作出修改，</p>
<ul>
<li><p>如果j-d[i] &gt;= 0，则可以把两种方法比较一下，看哪个小就选哪个，即式🍎</p>
</li>
<li><p>当然如果j-d[i] &lt; 0，那就把第二项改为一个特别大的数(如：9999)，这样我们最后自然选的就是第一种方法了。</p>
</li>
</ul>
<p>因此我们把第二项写作var ，var =  ( j&gt;=d[i] ) ? ( dp[i] [j-d[i]] + 1 ) : 9999</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//硬币兑换问题</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_dp</span><span class="params">(<span class="keyword">int</span> **dp,<span class="keyword">int</span> n,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=N;j++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>][j] = j;<span class="comment">//规定d1=1，则用j个一块钱可以兑换j块钱</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print_dp</span><span class="params">(<span class="keyword">int</span> **dp,<span class="keyword">int</span> n,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=N;j++)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;dp[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="comment">//打印dp</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CoinChanging</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *d,<span class="keyword">int</span> n,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> **dp= <span class="keyword">new</span> <span class="keyword">int</span>*[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        dp[i] =<span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    Init_dp(dp,n,N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> var= (j&gt;=d[i])?(dp[i][j-d[i]]+<span class="number">1</span>):<span class="number">9999</span>;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;var&lt;&lt;&quot; &quot;;</span></span><br><span class="line">            dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j],var);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    Print_dp(dp,n,N);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;兑换&quot;</span>&lt;&lt;N&lt;&lt;<span class="string">&quot;块钱需要：&quot;</span>&lt;&lt;dp[n][N]&lt;&lt;<span class="string">&quot;个币&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> dp[n][N];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> *d = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;d[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> N;<span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line">    CoinChanging(d,n,N);</span><br><span class="line">    <span class="comment">//cout&lt;&lt;&quot;兑换&quot;&lt;&lt;N&lt;&lt;&quot;块钱需要：&quot;&lt;&lt;CoinChanging(d,n,N)&lt;&lt;&quot;个币&quot;;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">input</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">1 2 5</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">output</span></span><br><span class="line"><span class="comment">0 0 0 0 0 0 0 0 0 </span></span><br><span class="line"><span class="comment">0 1 2 3 4 5 6 7 8 </span></span><br><span class="line"><span class="comment">0 1 1 2 2 3 3 4 4 </span></span><br><span class="line"><span class="comment">0 1 1 2 2 1 2 2 3 </span></span><br><span class="line"><span class="comment">兑换8块钱需要：3个币</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h1 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h1><p>/*<br>给出一个字符串S，求S的最长回文子串的长度<br>如：<br>input:<br>KATCJUJCTAUHBNC<br>output：<br>ATCJUJCTA,长度为9<br>*/</p>
<p>🍎思路：</p>
<p>我们以s表示字符串</p>
<p>我们以dp[i] [j]表示s[i]到s[j]这段子串是否为回文，是则为1，不是则为0</p>
<ol>
<li><p>想到边界（初始条件）：<br>dp[i] [i] = 1;//长度为1的回文</p>
<p>dp[i] [i+1]=(s[i]==s[i+1])?1:0 ;//长度为2的回文</p>
</li>
<li><p>我们希望转移方程简单化：</p>
<p>对于s[i]到s[j]是否为回文的判断，我们希望做到</p>
<p>若s[i]！=s[j]，那s[i]到s[j]自然不是回文</p>
<p>若s[i]= =s[j]，则看s[i+1]与s[j-1]，我们希望若s[i+1]==s[j-1]则可以判断s[i]到s[j]是回文</p>
<p><strong>那么我们就希望在判断长为L时，长度&lt;L的串的回文判断已经有了,</strong></p>
<p><strong>正是出于这个目的，我们才写了上面的dp[][]初始化，即先得到了对长度为1和长度为2的子串是否为回文的判断。</strong></p>
<p><strong>基于对长度为1和2的子串的判断，去算出对长度为3的，长度为4.。。。。的判断，这样最后就得到了所有长度的回文的判断</strong></p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最长回文字串</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">给出一个字符串S，求S的最长回文子串的长度</span></span><br><span class="line"><span class="comment">如：</span></span><br><span class="line"><span class="comment">字符串</span></span><br><span class="line"><span class="comment">KATCJUJCTAUHBNC</span></span><br><span class="line"><span class="comment">希望得到：</span></span><br><span class="line"><span class="comment">ATCJUJCTA,长度为9</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitDp</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> **dp,<span class="keyword">char</span> *s,<span class="keyword">int</span> &amp;maxlength)</span></span>&#123;<span class="comment">//边界（基本情况）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;<span class="comment">//长度为1的回文</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;n<span class="number">-1</span>)&#123;</span><br><span class="line">            dp[i][i+<span class="number">1</span>]=(s[i]==s[i+<span class="number">1</span>])?<span class="number">1</span>:<span class="number">0</span> ;<span class="comment">//长度为2的回文</span></span><br><span class="line">            maxlength=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetS</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HW</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> **dp,<span class="keyword">char</span> *s,<span class="keyword">int</span> &amp;maxlength)</span></span>&#123;<span class="comment">//可看上面🍎处的解释</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> L=<span class="number">3</span>;L&lt;=n;L++)&#123;<span class="comment">//转移方程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+L<span class="number">-1</span>&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = i+L<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[j] &amp;&amp; dp[i+<span class="number">1</span>][j<span class="number">-1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                dp[i][j] =<span class="number">1</span>;</span><br><span class="line">                maxlength = L;</span><br><span class="line">                <span class="comment">//cout&lt;&lt;L;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> maxlength;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OutputResult</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> **dp,<span class="keyword">char</span> *s,<span class="keyword">int</span> &amp;maxlength)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;最长回文子串长度为：&quot;</span>&lt;&lt;maxlength&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;此时最长回文子串为：\n&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+maxlength<span class="number">-1</span>&lt;n;i++)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> j=i+maxlength<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;count&lt;&lt;<span class="string">&quot;.&quot;</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;=j;k++)&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;s[k]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">char</span> s[n];</span><br><span class="line">    GetS(n,s);</span><br><span class="line">    <span class="keyword">int</span> maxlength=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> **dp = <span class="keyword">new</span> <span class="keyword">int</span> *[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        dp[i]=<span class="keyword">new</span> <span class="keyword">int</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    InitDp(n,dp,s,maxlength);<span class="comment">//初始化dp数组</span></span><br><span class="line">    HW(n,dp,s,maxlength);</span><br><span class="line">    </span><br><span class="line">    OutputResult(n,dp,s,maxlength);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">input1:</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">asaghgjkjo</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">output1:</span></span><br><span class="line"><span class="comment">最长回文子串长度为：3</span></span><br><span class="line"><span class="comment">此时最长回文子串为：</span></span><br><span class="line"><span class="comment">1. a s a </span></span><br><span class="line"><span class="comment">2. g h g </span></span><br><span class="line"><span class="comment">3. j k j</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">又如：</span></span><br><span class="line"><span class="comment">input2:</span></span><br><span class="line"><span class="comment">15</span></span><br><span class="line"><span class="comment">KATCJUJCTAUHBNC</span></span><br><span class="line"><span class="comment">output2</span></span><br><span class="line"><span class="comment">最长回文子串长度为：9</span></span><br><span class="line"><span class="comment">此时最长回文子串为：</span></span><br><span class="line"><span class="comment">1. A T C J U J C T A </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h1 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h1><p>/*</p>
<p><em>给定n种物品，每种物品一个</em></p>
<p><em>每个物品有其重量，有其价值</em></p>
<p><em>现在给你一个容量为V的包，</em></p>
<p><em>问怎么往里放物品，能让包里物品的总价值最大。</em></p>
<p>*/</p>
<p>直接去想怎么样价值最大有点突兀，因为各个物品的重量和价值不同，</p>
<p>一个容量为10kg的包，可能放进去3个物品占到9kg，也可能放进去5个物品占到8kg</p>
<p>我们的想法是用dp[i] [v]表示用前i个物品能放入容量v千克的包的时候时候，这i个物品的总价值</p>
<p>自然物品i至少能放入容量为w[i]的包，故v的范围为w[i]~V，而i的范围为1～<strong>n</strong>(dp二维数组中还会有第0行，看下面说的边界)</p>
<p>另有边界：</p>
<p>dp[0] [v]=0，无论拿来多大的包不放东西进去能获得的价值当然为0;</p>
<p>dp[i] [0]=0,包容量为零自然价值为0</p>
<p>由此我们得到了用前i个物品放入容量为w[i]的包的总价值，放入容量为w[i]+1的包的总价值。。。。放入容量为V的包的的总价值</p>
<p>由此我们得到前1个物品可能装成的重量的总价值，前两个，前三个。。。。。前n个物品可能装成重量的总价值</p>
<p>此时我们只要选择其中最大的即可，即最后返回的应该是最大的一个dp[i] [v]</p>
<p>dp[i] [v]怎么求呢？考虑v容量的包，现考虑物品i放入时的策略</p>
<p>如果不把物品i放入包中，则最大价值仍是前i-1件物品放进去容量v得到的最大价值,即dp[i-1] [v]；</p>
<p>如果把物品i放入包中，则最大价值为dp[i-1] [v-w[i]]+c[i]</p>
<p>我们自然选这两个决策中获得价值最大的一个，</p>
<p>(因为同样是容量v，而我们的物品价值并不是从小到大排列的，故我们是要考虑要不要把其他物品拿出来而选择把物品i放进去的。)</p>
<p>由此我们得到(dp[i] []这一行，（ 1&lt;= i &lt;=n）)：</p>
<p>​    dp[i] [v] = max{ dp[i-1] [v] , dp[i-1] [v-w[i]]+c[i] }（w[i]&lt;= v &lt;= V）</p>
<p>而当包的容量小于w[i]，物品i没法放进去，自然用物品1~i-1放进去了<br>            dp[i] [v]=dp[i-1] [v];</p>
<p>由此dp[i] []这一行的转移方程即为：</p>
<p>dp[i] [v] = max{ dp[i-1] [v] , dp[i-1] [v-w[i]]+c[i] }（w[i]&lt;= v &lt;= V）</p>
<p>dp[i] [v]=dp[i-1] [v]      （0&lt;= v &lt;=w[i]）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">时间：O(nV)</span></span><br><span class="line"><span class="comment">空间：O(nV)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Input</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> *A)</span></span>&#123;<span class="comment">//初始化数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    A[<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//为了让w,c数组1～n与dp数组行号及物品自然序号对应自然</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> *A)</span></span>&#123;<span class="comment">//打印数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;A[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitDp</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> V,<span class="keyword">int</span> **dp)</span></span>&#123;<span class="comment">//初始化dp数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        dp[i] = <span class="keyword">new</span> <span class="keyword">int</span>[V+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;<span class="comment">//由于我们上面分析的边界也是dp[0][v],dp[v][0]都为0，故这里直接将整个dp数组初始化为全0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;=V;v++)&#123;</span><br><span class="line">            dp[i][v]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintDp</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> V,<span class="keyword">int</span> **dp)</span></span>&#123;<span class="comment">//打印dp数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;=V;v++)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;dp[i][v]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MAXV</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> V,<span class="keyword">int</span> **dp,<span class="keyword">int</span> *w)</span></span>&#123;<span class="comment">//输出dp数组中的最大值，及我们最后的结果</span></span><br><span class="line">    <span class="keyword">int</span> MAXV=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=w[i];v&lt;=V;v++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][v]&gt;MAXV)&#123;</span><br><span class="line">                MAXV=dp[i][v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;MAXV&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bag</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> V,<span class="keyword">int</span> *w,<span class="keyword">int</span> *c)</span></span>&#123;<span class="comment">//算法核心</span></span><br><span class="line">    <span class="keyword">int</span> **dp = <span class="keyword">new</span> <span class="keyword">int</span>*[n+<span class="number">1</span>];</span><br><span class="line">    InitDp(n,V,dp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;w[i];v++)&#123;<span class="comment">//包的容量小于w[i]，物品i没法放进去，自然用物品1~i-1放进去了</span></span><br><span class="line">            dp[i][v]=dp[i<span class="number">-1</span>][v];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=w[i];v&lt;=V;v++)&#123;<span class="comment">//容量&gt;=w[i]，参见上面所讨论的</span></span><br><span class="line">            dp[i][v]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][v],dp[i<span class="number">-1</span>][v-w[i]]+c[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    MAXV(n,V,dp,w);</span><br><span class="line">    PrintDp(n,V,dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="comment">//n种物品</span></span><br><span class="line">    <span class="keyword">int</span> V;<span class="comment">//包的容量</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n; <span class="built_in">cin</span>&gt;&gt;V;</span><br><span class="line">    <span class="keyword">int</span> *w = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];<span class="comment">//用来存放各个物品的重量</span></span><br><span class="line">    <span class="keyword">int</span> *c = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];<span class="comment">//用来存放各个物品的价值</span></span><br><span class="line">    Input(n,w);<span class="comment">//输入各个物品的重量</span></span><br><span class="line">    Input(n,c);<span class="comment">//输入各个物品的价值</span></span><br><span class="line">    Output(n,w);<span class="comment">//打印w数组</span></span><br><span class="line">    Output(n,c);<span class="comment">//打印c数组</span></span><br><span class="line">    Bag(n,V,w,c);<span class="comment">//算法核心</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">input:</span></span><br><span class="line"><span class="comment">5 8</span></span><br><span class="line"><span class="comment">3 5 1 2 2</span></span><br><span class="line"><span class="comment">4 5 2 1 3</span></span><br><span class="line"><span class="comment">0 3 5 1 2 2 </span></span><br><span class="line"><span class="comment">0 4 5 2 1 3 </span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">0 0 0 0 0 0 0 0 0 </span></span><br><span class="line"><span class="comment">0 0 0 4 4 4 4 4 4 </span></span><br><span class="line"><span class="comment">0 0 0 4 4 5 5 5 9 </span></span><br><span class="line"><span class="comment">0 2 2 4 6 6 7 7 9 </span></span><br><span class="line"><span class="comment">0 2 2 4 6 6 7 7 9 </span></span><br><span class="line"><span class="comment">0 2 3 5 6 7 9 9 10 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">input:</span></span><br><span class="line"><span class="comment">5 10</span></span><br><span class="line"><span class="comment">2 6 3 6 9</span></span><br><span class="line"><span class="comment">9 1 4 9 5</span></span><br><span class="line"><span class="comment">0 2 6 3 6 9 </span></span><br><span class="line"><span class="comment">0 9 1 4 9 5 </span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">18</span></span><br><span class="line"><span class="comment">0 0 0 0 0 0  0  0  0  0  0 </span></span><br><span class="line"><span class="comment">0 0 9 9 9 9  9  9  9  9  9 </span></span><br><span class="line"><span class="comment">0 0 9 9 9 9  9  9  10 10 10 </span></span><br><span class="line"><span class="comment">0 0 9 9 9 13 13 13 13 13 13 </span></span><br><span class="line"><span class="comment">0 0 9 9 9 13 13 13 18 18 18 </span></span><br><span class="line"><span class="comment">0 0 9 9 9 13 13 13 18 18 18 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>因为从上面可以看出来，对i做决策的时候只与i-1有关</p>
<p>即，dp数组第i行只与第i-1行有关，而与本行或是甚么其他的无关了；</p>
<p>那我们不由的想了，</p>
<p>我们得到了第i-1行之后，直接在这行上面改，改完了把这行覆盖了不就得到了第i行了嘛！</p>
<p>哪还用得着开整整n*v这么大的数组呢。</p>
<p>我们仍然是对i和v循环</p>
<p>不同的就是我们不需要再对v&lt;=w[i]的地方专门说明了，因为对这些元素我们取的就是和上一行一样的，原因看第一种的说明。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//改进版本，优化了空间消耗</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">时间：O(nV)</span></span><br><span class="line"><span class="comment">空间：O(V)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="keyword">int</span> *dp = <span class="keyword">new</span> <span class="keyword">int</span>[V+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;=V;v++)&#123;</span><br><span class="line">        dp[v] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=V;v&gt;=w[i];v--)&#123;</span><br><span class="line">            dp[v]=<span class="built_in">max</span>(dp[v],dp[v-w[i]]+c[i]);</span><br><span class="line">        &#125;<span class="comment">//第一个dp[v]即上面的dp[i][v]</span></span><br><span class="line">      <span class="comment">//第二个dp[v]即dp[i-1][v],dp[v-w[i]]即dp[i-1][v-w[i]]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;=V;v++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[v]&gt;<span class="built_in">max</span>)&#123;</span><br><span class="line">            <span class="built_in">max</span>=dp[v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">max</span>;</span><br></pre></td></tr></table></figure>



</div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a></div><div class="post_share"><div class="social-share" data-image="/2019/10/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/cover.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/01/17/TCP-IP%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"><img class="prev-cover" data-lazy-src="/2020/01/17/TCP-IP%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/cover.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">TCP/IP体系结构</div></div></a></div><div class="next-post pull-right"><a href="/2019/10/15/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"><img class="next-cover" data-lazy-src="/2019/10/15/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/cover.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">树的遍历</div></div></a></div></nav></article></main><footer id="footer" style="background-image: url(/2019/10/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/top_img.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 江城子</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Thanks for visiting my <a target="_blank" rel="noopener" href="https://sosactwt.github.io/">page</a>!</div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  var script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>$(function () {
  $('span.katex-display').wrap('<div class="katex-wrap"></div>')
})</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>