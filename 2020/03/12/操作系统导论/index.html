<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>操作系统导论 | 大呓纪</title><meta name="description" content="操作系统导论梳理漫谈原版教材作者主页免费阅读： https:&#x2F;&#x2F;pages.cs.wisc.edu&#x2F;~remzi&#x2F;OSTEP&#x2F; 1.操作系统框架概述一个程序运行的过程： 处理器从内存中获取一条指令 ➡️ 对其进行解码（弄清楚这是哪条指令） ➡️ 然后执行它（做它该做的事情）。➡️再获取下一条指令，以此类推知道程序最终完成。 为了让程序运行变得更容易（甚至是同时运行多个程序），允许程序共享内存，让程"><meta name="keywords" content="Operating System"><meta name="author" content="江城子"><meta name="copyright" content="江城子"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="http://yoursite.com/2020/03/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="yandex-verification" content="{&quot;theme_color&quot;:{&quot;enable&quot;:true,&quot;main&quot;:&quot;#49B1F5&quot;}}"/><meta property="og:type" content="article"><meta property="og:title" content="操作系统导论"><meta property="og:url" content="http://yoursite.com/2020/03/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"><meta property="og:site_name" content="大呓纪"><meta property="og:description" content="操作系统导论梳理漫谈原版教材作者主页免费阅读： https:&#x2F;&#x2F;pages.cs.wisc.edu&#x2F;~remzi&#x2F;OSTEP&#x2F; 1.操作系统框架概述一个程序运行的过程： 处理器从内存中获取一条指令 ➡️ 对其进行解码（弄清楚这是哪条指令） ➡️ 然后执行它（做它该做的事情）。➡️再获取下一条指令，以此类推知道程序最终完成。 为了让程序运行变得更容易（甚至是同时运行多个程序），允许程序共享内存，让程"><meta property="og:image" content="http://yoursite.com/2020/03/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/cover.jpg"><meta property="article:published_time" content="2020-03-12T02:27:29.000Z"><meta property="article:modified_time" content="2021-04-13T01:41:07.052Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.0.2',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2021-04-13 09:41:07'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 5.0.2"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">8</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">9</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 基地</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 类别</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA%E6%A2%B3%E7%90%86%E6%BC%AB%E8%B0%88"><span class="toc-number">1.</span> <span class="toc-text">操作系统导论梳理漫谈</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">1.操作系统框架概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-1-%E8%99%9A%E6%8B%9F%E5%8C%96CPU"><span class="toc-number">3.</span> <span class="toc-text">1.1 虚拟化CPU</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-2-%E8%99%9A%E6%8B%9F%E5%8C%96%E5%86%85%E5%AD%98-virtualizing-memory"><span class="toc-number">4.</span> <span class="toc-text">1.2 虚拟化内存 (virtualizing memory)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-3-%E5%B9%B6%E5%8F%91"><span class="toc-number">5.</span> <span class="toc-text">1.3 并发</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-4-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87"><span class="toc-number">6.</span> <span class="toc-text">1.4 操作系统的设计目标</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB"><span class="toc-number">7.</span> <span class="toc-text">进程与线程的联系与区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">7.0.1.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.0.2.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%81%94%E7%B3%BB"><span class="toc-number">7.0.3.</span> <span class="toc-text">进程和线程的联系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.0.4.</span> <span class="toc-text">进程和线程的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A0%B9%E6%9C%AC%E5%8C%BA%E5%88%AB"><span class="toc-number">7.0.4.1.</span> <span class="toc-text">1.根本区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9C%A8%E5%BC%80%E9%94%80%E6%96%B9%E9%9D%A2"><span class="toc-number">7.0.4.2.</span> <span class="toc-text">2.在开销方面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%89%80%E5%A4%84%E7%9A%84%E7%8E%AF%E5%A2%83"><span class="toc-number">7.0.4.3.</span> <span class="toc-text">3.所处的环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">7.0.4.4.</span> <span class="toc-text">4.内存分配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E8%AE%A1%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.0.5.</span> <span class="toc-text">为什么要设计线程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A0%86%EF%BC%88Heap%EF%BC%89%E5%92%8C%E6%A0%88%EF%BC%88Stack%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.</span> <span class="toc-text">堆（Heap）和栈（Stack）的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%94%B3%E8%AF%B7%E6%96%B9%E5%BC%8F"><span class="toc-number">8.1.</span> <span class="toc-text">1.申请方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%94%B3%E8%AF%B7%E5%90%8E%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%93%8D%E5%BA%94"><span class="toc-number">8.2.</span> <span class="toc-text">2.申请后系统的响应</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%94%B3%E8%AF%B7%E5%A4%A7%E5%B0%8F%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">8.3.</span> <span class="toc-text">3.申请大小的限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%94%B3%E8%AF%B7%E6%95%88%E7%8E%87"><span class="toc-number">8.4.</span> <span class="toc-text">4.申请效率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%A0%86%E5%92%8C%E6%A0%88%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">8.5.</span> <span class="toc-text">5.堆和栈中存储的内容</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96CPU%EF%BC%88%E4%B8%BB%E8%A6%81%E4%B8%8E%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5%E7%9B%B8%E5%85%B3%EF%BC%89"><span class="toc-number">9.</span> <span class="toc-text">虚拟化CPU（主要与进程调度策略相关）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6%EF%BC%9A%E5%8F%97%E9%99%90%E7%9A%84%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8C-limit-direct-execution"><span class="toc-number">9.1.</span> <span class="toc-text">底层机制：受限的直接执行 limit direct execution</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F-User-mode"><span class="toc-number">9.1.1.</span> <span class="toc-text">用户模式 User mode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E6%A8%A1%E5%BC%8F-kernel-mode"><span class="toc-number">9.1.2.</span> <span class="toc-text">内核模式 kernel mode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">9.1.3.</span> <span class="toc-text">用户模式下的系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%B7%E9%98%B1%E6%8C%87%E4%BB%A4-%E4%B8%8E-%E4%BB%8E%E9%99%B7%E9%98%B1%E8%BF%94%E5%9B%9E%E6%8C%87%E4%BB%A4"><span class="toc-number">9.1.3.1.</span> <span class="toc-text">陷阱指令 与 从陷阱返回指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%B7%E9%98%B1%E8%A1%A8%EF%BC%9A%E9%85%8D%E7%BD%AE%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%E5%8F%91%E7%94%9F%E6%97%B6%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88-%E8%B7%B3%E5%88%B0%E5%93%AA%E6%AE%B5%E4%BB%A3%E7%A0%81"><span class="toc-number">9.1.3.2.</span> <span class="toc-text">陷阱表：配置特殊情况发生时该做什么(跳到哪段代码)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%88%87%E6%8D%A2"><span class="toc-number">9.1.4.</span> <span class="toc-text">进程之间的切换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E4%BD%9C%E6%96%B9%E5%BC%8F%EF%BC%9A%E7%AD%89%E5%BE%85%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">9.1.4.1.</span> <span class="toc-text">协作方式：等待系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E5%8D%8F%E4%BD%9C%E6%96%B9%E5%BC%8F%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E8%A1%8C%E6%8E%A7%E5%88%B6"><span class="toc-number">9.1.4.2.</span> <span class="toc-text">非协作方式：操作系统进行控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E5%AD%98%E5%92%8C%E6%81%A2%E5%A4%8D%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">9.1.4.3.</span> <span class="toc-text">保存和恢复上下文</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%B6%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="toc-number">9.2.</span> <span class="toc-text">父进程与子进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fork"><span class="toc-number">9.2.1.</span> <span class="toc-text">fork()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wait"><span class="toc-number">9.2.2.</span> <span class="toc-text">wait()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exec-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">9.2.3.</span> <span class="toc-text">exec()系统调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="toc-number">9.3.</span> <span class="toc-text">进程的调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1-First-Come-First-Served-FCFS-%E6%88%96%E7%A7%B0%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA-First-In-First-Out-FIFO"><span class="toc-number">9.3.1.</span> <span class="toc-text">1.先来先服务(First  Come First Served, FCFS),或称
先进先出(First  In First Out, FIFO)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9C%80%E7%9F%AD%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88%EF%BC%88Shortest-Job-First%EF%BC%8CSJF%EF%BC%89"><span class="toc-number">9.3.2.</span> <span class="toc-text">2.最短任务优先（Shortest Job First，SJF）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9C%80%E7%9F%AD%E5%AE%8C%E6%88%90%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88%EF%BC%88Shortest-Time-to-Complete-First-STCF%EF%BC%89"><span class="toc-number">9.3.3.</span> <span class="toc-text">3.最短完成时间优先（Shortest Time-to-Complete First, STCF）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%EF%BC%88Round-Robin-RR%EF%BC%89"><span class="toc-number">9.3.4.</span> <span class="toc-text">4.轮转调度（Round-Robin,RR）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">9.3.5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%BB%93%E5%90%88I-O"><span class="toc-number">9.3.6.</span> <span class="toc-text">5.结合I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%91%E4%BB%AC%E8%BF%98%E6%9C%89%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%E6%B2%A1%E8%80%83%E8%99%91%EF%BC%8C%E9%82%A3%E5%B0%B1%E6%98%AF%E6%88%91%E4%BB%AC%E5%B8%B8%E5%B8%B8%E5%9C%A8%E8%BF%90%E8%A1%8C%E4%B9%8B%E5%89%8D%E6%A0%B9%E6%9C%AC%E6%97%A0%E6%B3%95%E9%A2%84%E6%96%99%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1%E6%80%BB%E5%85%B1%E9%9C%80%E8%A6%81%E8%BF%90%E8%A1%8C%E5%A4%9A%E9%95%BF%E6%97%B6%E9%97%B4%EF%BC%81"><span class="toc-number">9.3.7.</span> <span class="toc-text">我们还有一个问题没考虑，那就是我们常常在运行之前根本无法预料一个任务总共需要运行多长时间！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%EF%BC%88Muti-level-Feedback-Queue%EF%BC%8CMLFQ%EF%BC%89"><span class="toc-number">9.3.8.</span> <span class="toc-text">6.多级反馈队列（Muti- level Feedback Queue，MLFQ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%AF%94%E4%BE%8B%E4%BB%BD%E9%A2%9D%EF%BC%88proportional-share%EF%BC%89%E8%B0%83%E5%BA%A6-%E5%85%AC%E5%B9%B3%E4%BB%BD%E9%A2%9D%EF%BC%88fair-share%EF%BC%89%E8%B0%83%E5%BA%A6"><span class="toc-number">9.3.9.</span> <span class="toc-text">7.比例份额（proportional- share）调度 &#x2F; 公平份额（fair- share）调度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96%E5%86%85%E5%AD%98%EF%BC%88%E5%85%B3%E4%BA%8E%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%90%91%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-number">10.</span> <span class="toc-text">虚拟化内存（关于虚拟地址向物理地址映射的问题）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">10.1.</span> <span class="toc-text">地址空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%99%9A%E6%8B%9F%E5%8C%96%E5%86%85%E5%AD%98"><span class="toc-number">10.2.</span> <span class="toc-text">如何虚拟化内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%BA%E5%88%B6%EF%BC%9A%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-number">10.3.</span> <span class="toc-text">机制：地址转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E5%9D%80%E5%8A%A0%E7%95%8C%E9%99%90%E6%9C%BA%E5%88%B6%EF%BC%88%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D%EF%BC%89"><span class="toc-number">10.3.1.</span> <span class="toc-text">基址加界限机制（动态重定位）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%EF%BC%9A%E6%B3%9B%E5%8C%96%E7%9A%84%E5%9F%BA%E5%9D%80-%E7%95%8C%E9%99%90"><span class="toc-number">10.3.2.</span> <span class="toc-text">分段：泛化的基址&#x2F;界限</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">10.3.2.1.</span> <span class="toc-text">段寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LDT%E8%A1%A8"><span class="toc-number">10.3.2.2.</span> <span class="toc-text">LDT表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GDT%E8%A1%A8"><span class="toc-number">10.3.2.3.</span> <span class="toc-text">GDT表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">10.3.2.4.</span> <span class="toc-text">分段的优点:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%A0%88%E7%9A%84%E5%81%8F%E7%A7%BB%E9%87%8F"><span class="toc-number">10.3.2.5.</span> <span class="toc-text">关于栈的偏移量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB"><span class="toc-number">10.3.2.6.</span> <span class="toc-text">共享</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E7%A2%8E%E7%89%87"><span class="toc-number">10.3.2.7.</span> <span class="toc-text">外部碎片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8%E7%AE%A1%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-number">10.3.2.8.</span> <span class="toc-text">空闲列表管理算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8%E7%9A%84%E6%9C%BA%E5%88%B6%EF%BC%9A%E5%88%86%E5%89%B2%E4%B8%8E%E5%90%88%E5%B9%B6"><span class="toc-number">10.3.2.8.1.</span> <span class="toc-text">空闲列表的机制：分割与合并</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8"><span class="toc-number">10.3.2.9.</span> <span class="toc-text">嵌入空闲列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-number">10.3.2.10.</span> <span class="toc-text">分配策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">10.3.2.11.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(/2020/03/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/top_img.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">大呓纪</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 基地</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 类别</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">操作系统导论</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2020-03-12T02:27:29.000Z" title="undefined 2020-03-12 10:27:29">2020-03-12</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>47分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="操作系统导论梳理漫谈"><a href="#操作系统导论梳理漫谈" class="headerlink" title="操作系统导论梳理漫谈"></a>操作系统导论梳理漫谈</h1><p>原版教材作者主页免费阅读：</p>
<p><a target="_blank" rel="noopener" href="https://pages.cs.wisc.edu/~remzi/OSTEP/">https://pages.cs.wisc.edu/~remzi/OSTEP/</a></p>
<h1 id="1-操作系统框架概述"><a href="#1-操作系统框架概述" class="headerlink" title="1.操作系统框架概述"></a>1.操作系统框架概述</h1><p>一个程序运行的过程：</p>
<p>处理器从内存中获取一条指令 ➡️ 对其进行解码（弄清楚这是哪条指令） ➡️ 然后执行它（做它该做的事情）。➡️再获取下一条指令，以此类推知道程序最终完成。</p>
<p>为了让程序运行变得更容易（甚至是同时运行多个程序），允许程序共享内存，让程序能够与设备交互等等，我们便采用了一类称之为<strong>操作系统</strong>的软件（<strong>Operating System，OS</strong>）。</p>
<p>要做到这些事情，操作系统主要利用一种通用的技术，我们称之为<strong>虚拟化</strong>，即OS将物力资源(如处理器、内存、磁盘等)转换为更通用、更强大、更易于使用的虚拟形式，故我们也将OS称作**虚拟机(virtual machine)**。</p>
<p>为了让用户告诉OS做什么，从而利用虚拟机的功能，OS还会提供一系列借口（API）供你调用。典型的OS会提供几百个系统调用(system call)，让应用程序调用，以实现访问内存和设备、进行其它相关操作的等目的。由此，我们也常说OS为应用程序提供了一个**标准库(standard library)**。</p>
<p>最后，因为OS让应用程序运行(从而共享CPU)，让许多程序可以同时访问自己的指令和数据(从而共享内存)，让许多程序访问设备(从而共享磁盘等)，所以操作系统有时也被称为**资源管理器(resource manager)**。每个CPU、内存和磁盘都是系统的资源(resource)，因此操作系统扮演的主要角色就是管理(manage)这些资源。</p>
<h1 id="1-1-虚拟化CPU"><a href="#1-1-虚拟化CPU" class="headerlink" title="1.1 虚拟化CPU"></a>1.1 虚拟化CPU</h1><p>通俗易懂地理解：即使我们希望在一个单CPU上同时运行多个程序也可以做到，事实上这是操作系统在一些硬件帮助下提供的假象，即OS拥有非常多个CPU的假象，将单个CPU(或其中一小部分)转换为看似无限数量的CPU，从而让许多程序看似同时运行，这就是所谓的<strong>虚拟化CPU</strong>。至于是如何做到的，以及类似于两个程序在某个特定的时间都要运行该运行哪个这类问题，都属于操作系统的策略，是操作室同实现的基本机制问题，这些都会在后面详谈。</p>
<h1 id="1-2-虚拟化内存-virtualizing-memory"><a href="#1-2-虚拟化内存-virtualizing-memory" class="headerlink" title="1.2 虚拟化内存 (virtualizing memory)"></a>1.2 虚拟化内存 (virtualizing memory)</h1><p>通俗化理解就是：好像每个正在运行的程序都有自己的私有内存，而不是与其他正在运行的程序共享相同的物理内存。（如我们或许可以实验发现两个同时运行的程序的操作对象打印出来的地址指向的是同一个地址，不过这一点在日常用的电脑上试不出来，要先禁用一下地址空间随机化。）</p>
<p>这就是操作系统虚拟化内存时发生的情况。每个进程访问自己的私有虚拟地址空间(virtual address space)，（有时候简称为地址空间），操作系统以某种方式再将其映射到机器的物理内存上。如此一来正在运行的内存饮用不会影响其他进程(或是OS本身)的地址空间。对于正在运行的程序，它似乎完全拥有自己的物理内存，但实际上物理内存是操作系统管理的共享资源。</p>
<h1 id="1-3-并发"><a href="#1-3-并发" class="headerlink" title="1.3 并发"></a>1.3 并发</h1><p>并发这个术语用来指代一些列的问题，这些问题在同时(并发地)处理很多事情时出现且必须解决。</p>
<p>不管是操作系统本身同时处理很多事情，还是现代多线程程序(multi- threaded)都存在这些问题。</p>
<h1 id="1-4-操作系统的设计目标"><a href="#1-4-操作系统的设计目标" class="headerlink" title="1.4 操作系统的设计目标"></a>1.4 操作系统的设计目标</h1><ul>
<li>提供高性能，我们的目标是最小化操作系统的开销。</li>
<li>隔离。我们希望应用程序之间，OS和应用程序之间都能提供保护，使一个应用程序的恶意或意外行为不至于损害其他程序，当然更不希望损害到OS本身。保护是操作系统基本原理之一的核心，也就是所谓的隔离。让进程彼此隔离是保护的关键，这也决定的OS必须执行的大部分任务。</li>
<li>可靠性。OS要能够不间断运行，否则它一失效，系统上运行的程序也就失效了。</li>
</ul>
<h1 id="进程与线程的联系与区别"><a href="#进程与线程的联系与区别" class="headerlink" title="进程与线程的联系与区别"></a>进程与线程的联系与区别</h1><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是程序的一次执行过程，是一个动态概念，</p>
<p>它是程序在执行过程中<strong>分配和管理资源的基本单位</strong>，每个进程都有一个自己的地址空间。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是<strong>CPU调度和分配，执行的基本单位</strong>，它可以和同属于一个进程的其他线程共享这个进程所拥有的全部资源。</p>
<h3 id="进程和线程的联系"><a href="#进程和线程的联系" class="headerlink" title="进程和线程的联系"></a>进程和线程的联系</h3><p>线程是进程的一部分，且一个线程只属于一个进程；</p>
<p>而一个进程可以有多个线程，但至少有一个线程。</p>
<p>当我们未提及线程时的程序可以看作是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线(线程)共同完成的，线程是进程的一部分，所以线程也被称轻量级进程。</p>
<h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><h4 id="1-根本区别"><a href="#1-根本区别" class="headerlink" title="1.根本区别"></a>1.根本区别</h4><p>进程是OS资源分配的基本单位，</p>
<p>线程是任务调度和执行的基本单位。</p>
<h4 id="2-在开销方面"><a href="#2-在开销方面" class="headerlink" title="2.在开销方面"></a>2.在开销方面</h4><p>每个<strong>进程</strong>有独立的代码和数据空间(上下文，context)，进程之间切换会有较大的开销；</p>
<p>而<strong>线程</strong>可以看作是轻量级的进程，同一个进程下的线程共享代码和数据空间，</p>
<p><font color="indianred" size="4">不过</font>**每个线程都有自己独立的运行栈和程序计数器(PC)**，线程之间切换的开销更小。</p>
<h4 id="3-所处的环境"><a href="#3-所处的环境" class="headerlink" title="3.所处的环境"></a>3.所处的环境</h4><p>在一个OS中能同时运行多个进程，</p>
<p>而在同一个进程中有多个线程同时执行（通过CPU调度，在每个时间片只有一个线程执行）。</p>
<h4 id="4-内存分配"><a href="#4-内存分配" class="headerlink" title="4.内存分配"></a>4.内存分配</h4><p>当系统运行时，会为每个进程分配不同的内存空间，</p>
<p>而对线程而言，除了CPU外，系统不会为线程分配内存等资源，线程所使用的资源来来自其所属进程的资源，进程组之间只能共享资源。</p>
<h3 id="为什么要设计线程"><a href="#为什么要设计线程" class="headerlink" title="为什么要设计线程"></a>为什么要设计线程</h3><p>传统进程模型中，进程的内涵可以分为两方面：</p>
<ul>
<li>调度执行的基本单位，每个进程有自己的运行状态，优先级，寄存器等等，是OS调度的基本单位；</li>
<li>资源所有权：包括程序、数据和文件等资源，一个进程拥有对这些资源的所有权，OS则提供保护功能，避免不同进程之间的资源冲突</li>
</ul>
<p>既然是两个独立的功能，那自然可以将它们分离，这就出现了线程的概念，由此：</p>
<ul>
<li>执行与调度的基本单位：线程</li>
<li>资源的所有权：进程</li>
</ul>
<p>这样做的好处：</p>
<p>操作系统中有两个重要概念：并发和隔离</p>
<p><strong>并发：</strong>是为了尽量让硬件利用率高，线程就是为了在系统层面做到并发，因为线程的上下文切换效率比进程上下文的切换高很多，这样可以提高并发率。</p>
<p><strong>隔离：</strong>也是并发之后要解决的问题，计算机资源一般是共享的，隔离要能保障崩溃了的资源能够被回收，不影响其他代码的使用，所以OS只有线程而没有进程其实也是可以的，只是OS会经常崩溃罢了，OS刚发展时和这种情形很像，而进程则有自己独立的数据空间，进程之间互不影响，保证了对各进程的有效隔离。</p>
<p>故说，线程和并发有关，进程和隔离有关，线程基本是为了并发执行而引入的概念，进程相当于一堆线程加上执行过程申请的资源，一旦挂了这些资源都要能回收，不影响其他程序。</p>
<h1 id="堆（Heap）和栈（Stack）的区别"><a href="#堆（Heap）和栈（Stack）的区别" class="headerlink" title="堆（Heap）和栈（Stack）的区别"></a>堆（Heap）和栈（Stack）的区别</h1><h2 id="1-申请方式"><a href="#1-申请方式" class="headerlink" title="1.申请方式"></a>1.申请方式</h2><p>栈（Stack）：由系统分配</p>
<p>堆（Heap）：可以程序员手动申请任意大小的内存并释放</p>
<h2 id="2-申请后系统的响应"><a href="#2-申请后系统的响应" class="headerlink" title="2.申请后系统的响应"></a>2.申请后系统的响应</h2><p>栈：只要栈的剩余空间大于所申请空间系统就会为程序提供内存，否则会报异常提示栈溢出。</p>
<p>堆：OS内有记录空闲内存地址的空闲链表，当OS收到申请后会遍历该链表，寻找第一个空间大于所申请的空间的堆结点，然后将该结点从空闲节点链表中删除，并将该结点的空间分配给程序。对于大多数系统而言，会在这块内存空间的首地址处记录本次分配的大小，这样代码中的delete语句才能正确地释放本内存空间。</p>
<p>找到的堆结点的大小不一定正好等于申请的大小，系统会自动将多余的那部分重新放入空闲链表中。</p>
<h2 id="3-申请大小的限制"><a href="#3-申请大小的限制" class="headerlink" title="3.申请大小的限制"></a>3.申请大小的限制</h2><p>栈：栈由高地址向低地址扩展，是一块连续的内存区域，也就是说栈底的地址和栈的最大容量是系统预先规定好的，如果申请的空间超过栈的剩余空间时，将会提示overflow，因此能从栈中获得的空间较小。</p>
<p>堆：堆是向高地址扩展的数据结构，且是不连续的内存区域，这是由于系统是用链表来存储空闲的内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址扩展的，堆的大小受限于计算机系统有效的虚拟内存，由此可见，堆获得的空间比较灵活，也比较大。</p>
<h2 id="4-申请效率"><a href="#4-申请效率" class="headerlink" title="4.申请效率"></a>4.申请效率</h2><p>栈：由系统自动分配，速度较快，但是程序员无法控制，</p>
<p>堆：一般速度比较慢，而且容易产生内存碎块，不过用起来灵活方便。</p>
<h2 id="5-堆和栈中存储的内容"><a href="#5-堆和栈中存储的内容" class="headerlink" title="5.堆和栈中存储的内容"></a>5.堆和栈中存储的内容</h2><p>栈：函数调用信息，参数，返回值，分配局部变量，</p>
<p>堆：动态内存分配。</p>
<h1 id="虚拟化CPU（主要与进程调度策略相关）"><a href="#虚拟化CPU（主要与进程调度策略相关）" class="headerlink" title="虚拟化CPU（主要与进程调度策略相关）"></a>虚拟化CPU（主要与进程调度策略相关）</h1><h2 id="底层机制：受限的直接执行-limit-direct-execution"><a href="#底层机制：受限的直接执行-limit-direct-execution" class="headerlink" title="底层机制：受限的直接执行 limit direct execution"></a>底层机制：受限的直接执行 limit direct execution</h2><p><strong>直接执行</strong>，即直接在硬件CPU上运行，以保证执行速度可以很快。</p>
<p>但我们有两个想法：</p>
<ul>
<li>希望保证程序不会做我们所要求的任务以外的“坏事”，即我们要保证操作系统的控制权。🍎</li>
<li>希望需要时可以将它停下来切换到另一个进程，从而实现虚拟化CPU所需的时分共享。🍎🍎</li>
</ul>
<p>因此我们希望程序的一些操作是<strong>受到一些限制</strong>的，如向磁盘发出I/O请求或获得更多系统资源。</p>
<p>由此我们引入了用户模式和内核模式。</p>
<p>🍎：先看系统控制权怎么保证。</p>
<h3 id="用户模式-User-mode"><a href="#用户模式-User-mode" class="headerlink" title="用户模式 User mode"></a>用户模式 User mode</h3><p>在用户模式下运行的代码会受到限制。</p>
<p>如，用户模式下，进程不能发出I/O请求，如果这样做了会导致处理器发生异常，操作系统可能会终止进程。</p>
<h3 id="内核模式-kernel-mode"><a href="#内核模式-kernel-mode" class="headerlink" title="内核模式 kernel mode"></a>内核模式 kernel mode</h3><p>操作系统（或内核）就以这种模式运行，在此模式下运行的代码可以做它喜欢的事情，包括特权操作，如发出I/O请求和执行所有类型的受限指令。</p>
<h3 id="用户模式下的系统调用"><a href="#用户模式下的系统调用" class="headerlink" title="用户模式下的系统调用"></a>用户模式下的系统调用</h3><p>因为用户有时候也希望执行某种特权操作，如从磁盘读取。因此，几乎所有的现代硬件都提供了用户程序执行系统调用的能力。</p>
<p>系统调用允许内核小心地向用户程序暴露某些功能，例如访问文件系统、创建和销毁进程、与其他进程通信，以及分配更多内存。</p>
<p>大多数操作系统提供几百个调用。</p>
<h4 id="陷阱指令-与-从陷阱返回指令"><a href="#陷阱指令-与-从陷阱返回指令" class="headerlink" title="陷阱指令 与 从陷阱返回指令"></a>陷阱指令 与 从陷阱返回指令</h4><p>想要执行系统调用，程序必须执行特殊的陷阱指令。</p>
<p>👉该指令将跳入内核，并将特权级别提升到内核模式。一旦进入内核，系统就可以执行任何需要的特权操作(如果允许)，从而为调用进程执行所需的工作。</p>
<p>👉完成后，OS调用从陷阱返回指令，该指令返回发起调用的用户程序中，同时将特权级别降低，回到用户模式。</p>
<p>🧠：执行陷阱的时候 ，硬件必须确保储存足够多的调用者寄存器，以便在OS发出从陷阱返回指令时能够正确返回。如x86上，处理器会将程序计数器、标志和其他一些寄存器推送到每个进程的内核栈上；从陷阱返回时将从栈弹出这些值，并恢复用户模式程序。</p>
<h4 id="陷阱表：配置特殊情况发生时该做什么-跳到哪段代码"><a href="#陷阱表：配置特殊情况发生时该做什么-跳到哪段代码" class="headerlink" title="陷阱表：配置特殊情况发生时该做什么(跳到哪段代码)"></a>陷阱表：配置特殊情况发生时该做什么(跳到哪段代码)</h4><p>🧠思考一个问题：<strong>发起调用时，陷阱如何知道该在OS内运行哪些代码呢？</strong>（即我们发起某个调用或者是发生中断时，陷阱指令需要知道该去让系统做那些事情。）</p>
<p>我们显然不能让调用程序去指定要跳转到的位置，这样让程序可以跳转到内核中的任意位置肯定不安全。</p>
<p>为此我们设置了陷阱表，它在内核启动的时候就进行设置。</p>
<p>机器启动时是在特权(内核)模式下执行的，因此可以根据需要自由配置机器硬件。OS第一件要做的就是告诉硬件，在发生某些异常事件(如系统调用，硬盘中断，键盘中断)时需要运行哪些代码来处理。</p>
<p>OS通常用某种特殊指令通知硬件陷阱处理程序的位置，硬件一旦被告知就会记住这些处理程序的位置，(直到下一次重新启动机器)，并知道了在发生系统调用和其他异常事件的时候需要做什么(即跳到哪段代码)。</p>
<p>🍎🍎：现在来看进程切换的问题。</p>
<h3 id="进程之间的切换"><a href="#进程之间的切换" class="headerlink" title="进程之间的切换"></a>进程之间的切换</h3><p>🧠问题的关键：当一个进程在CPU上运行，这意味着OS此时没有运行，那么它该如何重新获得对CPU的控制权以切换其他进程呢。</p>
<p>有两种方式：</p>
<h4 id="协作方式：等待系统调用"><a href="#协作方式：等待系统调用" class="headerlink" title="协作方式：等待系统调用"></a>协作方式：等待系统调用</h4><p>这种方法即当一个进程进行系统调用时，将CPU控制权转移给操作系统；</p>
<p>如果应用进程执行了某些非法操作，也会将控制权转移给OS，如以0为除数或者尝试访问无法访问的内存，就会陷入操作系统，那OS便将再次控制CPU(并可能终止违规进程)。</p>
<p>👹：但是我们可以看到这样的话操作系统只能等进程进行系统调用或者程序出错或非法才能重新“夺得”(被施舍)控制权，这岂不是太被动了吗？👇</p>
<h4 id="非协作方式：操作系统进行控制"><a href="#非协作方式：操作系统进行控制" class="headerlink" title="非协作方式：操作系统进行控制"></a>非协作方式：操作系统进行控制</h4><p>协作方式让OS太被动，想主动也可以——关机大法。。。</p>
<p>非协作方法用了一个很简单的办法：<strong>时钟中断(timer inerrupt)</strong></p>
<p>时钟设备可以编程为每隔几毫秒产生一次中断，产生中断时，当前正在运行的进程停止，操作系统中预先配置的中断处理程序就会运行。此时操作系统重新获得CPU的控制权，便可以做它想做的事，如我所需要的：停止当前进程，并启动另一个进程。</p>
<p>这不光是关于进程切换，也对帮助OS维持机器的控制权至关重要。</p>
<p>🧠我们同样是在启动时OS通知硬件哪些代码在发生时钟中断时运行；当然在启动过程中我们自然也必须启动时钟，这也是一项特权操作。（需要时时钟也可以被关闭，当然这也是一项特权操作。）</p>
<p>和程序进行系统调用时类似，当发生中断时，硬件要为本来真在运行的程序保存足够的状态，以便随后从陷阱返回指令能够正确恢复真在运行的程序。整个过程也是：各种寄存器被保存进入内核栈，结束后从陷阱返回指令可以容易地恢复。</p>
<h4 id="保存和恢复上下文"><a href="#保存和恢复上下文" class="headerlink" title="保存和恢复上下文"></a>保存和恢复上下文</h4><p>🧠无论是协作方式还是非协作，系统拿到控制权后都要决定：继续当前程序，还是切换到别的程序。</p>
<p>​    ——这个决定由调度程序做出，它是OS的一部分。（进程调度将在后面详谈）</p>
<p>这里主要说切换的底层机制。</p>
<p>如果决定切换，OS就会执行一些底层的代码，即**上下文切换(context switch)**。</p>
<p><strong>上下文切换：</strong>系统要做的就是为当前正在执行的进程保存一些寄存器的值(比如保存到内核栈)，为将要执行的进程恢复一些寄存器的值（从内核栈），<u>如此一来系统可以确保最后执行从陷阱返回指令时，不是返回到之前运行的进程，而是继续执行另一段进程。</u></p>
<p>OS会执行一些底层汇编代码，以</p>
<p>保存当前正在运行进程的上下文，来保存通用寄存器、程序计数器以及当前进程的内核栈指针；</p>
<p>恢复寄存器、程序计数器，并<u>切换内核栈</u>，供即将运行的进程使用。</p>
<p>通过切换栈，</p>
<p>内核在进入切换代码调用时，是一个进程(被中断的进程)的上下文；</p>
<p>而在返回时，则是另一个进程(即将执行的进程)的上下文。</p>
<p>如此，当OS最终执行从陷阱返回指令的时候，即完成了上下文与进程的切换。</p>
<p> 🧠要是一个中断时或是进行陷阱处理过程中，又发生了另一个中断怎么办呢？那就是后面并发要讲的东西了。</p>
<h2 id="父进程与子进程"><a href="#父进程与子进程" class="headerlink" title="父进程与子进程"></a>父进程与子进程</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello my pid:%d\n&quot;</span>,(<span class="keyword">int</span>)getpid());</span><br><span class="line">        <span class="keyword">int</span> rc = fork();</span><br><span class="line">        <span class="keyword">if</span>(rc&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;fork failed.\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rc == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;hello , i am a child. pid:%D\n&quot;</span>,(<span class="keyword">int</span>)getpid());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;hello ,i am parent of %d ,my pid:%d\n&quot;</span>,rc,(<span class="keyword">int</span>)getpid());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">➜ gcc -o fork fork.c</span><br><span class="line">➜ ./fork            </span><br><span class="line">hello my pid:<span class="number">5489</span></span><br><span class="line">hello ,i am parent of <span class="number">5490</span> ,my pid:<span class="number">5489</span><span class="comment">//rc&gt;0</span></span><br><span class="line">hello , i am a child. pid:<span class="number">5490</span><span class="comment">//rc=0</span></span><br></pre></td></tr></table></figure>



<p>关于fork():</p>
<p>我们用fork函数创建新进程（子进程）</p>
<p>原来从main开始的原始进程为父进程，</p>
<p>而子进程则不会从main开始执行(可以看到hello my pid:5489这句话只执行了一次。)，而是直接从fork()系统调用返回，就好像是它自己调用了fork()一样。</p>
<p>因此也可以看出来，子进程并不是完全拷贝父进程，虽然他有自己的地址空间（即拥有自己的私有内存）、寄存器、程序计数器等等，但是他从fork返回的值是不同的。</p>
<p>父进程获得的返回值（即rc被赋予的值）是新创建的子进程的PID，而子进程获得的返回值是0，若是小于0，则说明创建子进程失败了。</p>
<p>这里是parent即父进程先打印出来，但实际上不一定，要取决于CPU的调度，它决定了哪个时刻哪个进程被执行。CPU调度程序非常复杂，我们不能假设哪个进程会先运行。</p>
<h3 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h3><p>从上面可以知道，父子进程的执行先后不一定，但如果我想让某一个先执行呢？比如碰巧是父进程先执行，但是我非要让子进程先执行，那么我们可以让父进程先等一等，等子进程先去执行，执行完了再来执行父进程，这个任务便由wait()函数（或者更完整的兄弟接口waitpid()）来完成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello my pid:%d\n&quot;</span>,(<span class="keyword">int</span>)getpid());</span><br><span class="line">    <span class="keyword">int</span> rc = fork();</span><br><span class="line">    <span class="keyword">if</span>(rc&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;fork failed.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(rc == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello , i am a child. pid:%D\n&quot;</span>,(<span class="keyword">int</span>)getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> wc = wait(<span class="literal">NULL</span>);<span class="comment">//与之前的区别</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello ,i am parent of %d , wc:%d,my pid:%d\n&quot;</span>,rc,wc,(<span class="keyword">int</span>)getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">➜ gcc -o wait wait.c</span><br><span class="line">➜ ./wait</span><br><span class="line">hello my pid:<span class="number">5623</span></span><br><span class="line">hello , i am a child. pid:<span class="number">5624</span></span><br><span class="line">hello ,i am parent of <span class="number">5624</span> , wc:<span class="number">5624</span>,my pid:<span class="number">5623</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到现在是孩子先出来了，当然你也可以说是碰巧先执行了孩子，这也是有可能的，但是如果先轮到了parent，最后还是会先让给孩子。另外wait()的返回值就是被等待的那个进程的PID（这里即子进程）。</p>
<p>因此我们通过wait()让输出结果变得确定了。</p>
<h3 id="exec-系统调用"><a href="#exec-系统调用" class="headerlink" title="exec()系统调用"></a>exec()系统调用</h3><p>之前通过fork()得到的子进程与父进程执行的都是一样的程序，如果我们希望他们执行不同的程序，则exec()可以做这样的事。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello my pid:%d\n&quot;</span>,(<span class="keyword">int</span>)getpid());</span><br><span class="line">    <span class="keyword">int</span> rc = fork();</span><br><span class="line">    <span class="keyword">if</span>(rc&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;fork failed.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(rc == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello , i am a child. pid:%D\n&quot;</span>,(<span class="keyword">int</span>)getpid());</span><br><span class="line">        <span class="keyword">char</span>* myargs[<span class="number">3</span>];</span><br><span class="line">        myargs[<span class="number">0</span>] = strdup(<span class="string">&quot;wc&quot;</span>);</span><br><span class="line">        myargs[<span class="number">1</span>] = strdup(<span class="string">&quot;exec.c&quot;</span>);</span><br><span class="line">        myargs[<span class="number">2</span>] = <span class="literal">NULL</span>;<span class="comment">//字符数组结尾</span></span><br><span class="line">        execvp(myargs[<span class="number">0</span>],myargs);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;look at me.\n&quot;</span>);<span class="comment">//执行了execvp成功后，当前的程序就被替换成wc程序了，execvp()的成功调用永远不会返回，故不会执行这句话了。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> wc = wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello ,i am parent of %d , wc:%d,my pid:%d\n&quot;</span>,rc,wc,(<span class="keyword">int</span>)getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  gcc -o exec exec.c</span><br><span class="line">➜  ./exec            </span><br><span class="line">hello my pid:<span class="number">5871</span></span><br><span class="line">hello , i am a child. pid:<span class="number">5872</span></span><br><span class="line">      <span class="number">27</span>      <span class="number">67</span>     <span class="number">667</span> exec.c</span><br><span class="line">hello ,i am parent of <span class="number">5872</span> , wc:<span class="number">5872</span>,my pid:<span class="number">5871</span></span><br></pre></td></tr></table></figure>



<h2 id="进程的调度"><a href="#进程的调度" class="headerlink" title="进程的调度"></a>进程的调度</h2><p>上下文切换这类算是进程的底层机制(mechanism)的话，那下面要说的进程调度算是OS调度程序采用的上层策略(sheduling policy)了。</p>
<p>定义周转时间：</p>
<p>​                                    T周转时间 = T完成时间 - T到达时间</p>
<h3 id="1-先来先服务-First-Come-First-Served-FCFS-或称先进先出-First-In-First-Out-FIFO"><a href="#1-先来先服务-First-Come-First-Served-FCFS-或称先进先出-First-In-First-Out-FIFO" class="headerlink" title="1.先来先服务(First  Come First Served, FCFS),或称先进先出(First  In First Out, FIFO)"></a>1.先来先服务(First  Come First Served, FCFS),或称<br>先进先出(First  In First Out, FIFO)</h3><p>我们假设所有任务A，B，C几乎同时在0时到达，（假设）A比B早一点点点，B比C早一点点点，每个工作时间都需要10秒钟</p>
<p>那么A先做，B再做，C再做，则A，B，C的周转时间大约是10，20，30</p>
<p>则平均周转时间：（10+20+30）/3=20</p>
<p>然而若A的工作时间为100，B为10，C为10，</p>
<p>则平均周转时间：（100+110+120）/3=110，显然若是B或C可以先做的话平均周转时间会小很多</p>
<p>⬇️</p>
<h3 id="2-最短任务优先（Shortest-Job-First，SJF）"><a href="#2-最短任务优先（Shortest-Job-First，SJF）" class="headerlink" title="2.最短任务优先（Shortest Job First，SJF）"></a>2.最短任务优先（Shortest Job First，SJF）</h3><p>我们仍然假设他们同时到达，A工作时间需要100，B为10，C为10</p>
<p>因为先让B或C工作，</p>
<p>由此，平均周转时间：（10+20+120）/3=50显然快多了</p>
<blockquote>
<p>在假设所有任务同时到达的情况下，最短任务优先时最优的。</p>
</blockquote>
<p>然而，如果到达时间不同呢？</p>
<p>A先到，运行100，B和C在10的时候到也要等到100之后才能工作，</p>
<p>则平均周转时间：（100+110+120）/3 = 110</p>
<p>如果A能在中间停下来先让B和C先来拿B和C的周转时间会小很多，平均周转时间自然会小很多。</p>
<p>⬇️</p>
<h3 id="3-最短完成时间优先（Shortest-Time-to-Complete-First-STCF）"><a href="#3-最短完成时间优先（Shortest-Time-to-Complete-First-STCF）" class="headerlink" title="3.最短完成时间优先（Shortest Time-to-Complete First, STCF）"></a>3.最短完成时间优先（Shortest Time-to-Complete First, STCF）</h3><p>基于能让A停下来的猜想，我们可以采用抢占式调度程序，即当B和C到达时我们可以抢占工作A，并运行B或C，等B和C完成后，再继续做A。</p>
<p>最短完成时间优先就是这样的调度程序，因此也被称作抢占式最短作业优先（Preemptive Shortest Job First，PSJF）。它可以看作是抢占式的最短任务优先。</p>
<p>每当新工作进入系统时候，调度程序就会判断当前剩余工作和新工作中，谁的剩余时间最少，然后调度改工作。</p>
<p>A：0时到达，需要时间100</p>
<p>B：10时到达，需要10</p>
<p>C：10时到达，需要10</p>
<p>自然A先运行，运行到10时候，B，C来了</p>
<p>此时A还需要90，而B、C需要10即可，故先做B（C也可以）</p>
<p>B做完时是20，B的周转时间为20-10=10</p>
<p>这时候A还需要90，C需要10，故先做C</p>
<p>C从20的时候开始做，做完时为30，C的周转时间：30-10=20</p>
<p>现在只剩下A，需要90，继续做A，做完后时间来到了120，A的周转时间：120 - 0 = 120</p>
<p>故平均周转时间只有（10+20+120）/3 = 50</p>
<h3 id="4-轮转调度（Round-Robin-RR）"><a href="#4-轮转调度（Round-Robin-RR）" class="headerlink" title="4.轮转调度（Round-Robin,RR）"></a>4.轮转调度（Round-Robin,RR）</h3><p>引入一个新的指标：响应时间（Response Time），意思是任务A从到达到能被执行需要等待多长时间</p>
<p>从上面那个例子来看，</p>
<p>A到了就可以执行，RT = 0</p>
<p>B到了就可以执行，RT = 0</p>
<p>C到了却要等十秒钟等B做完了才能执行，RT=10</p>
<p><strong>轮转调度</strong>正是为了解决这个问题而被引入的。</p>
<p>基本思想：RR是在一个时间片内运行一个工作，这个时间片结束就切换到下一个任务，而不是一直运行同一个任务。如此反复直到所有任务完成。因此轮转调度有时候被称为时间切片（time-slicing）。</p>
<p>⚠️：时间片长度必须是时钟中断周期的倍数。</p>
<p>即若时钟中断是10ms中断一次，则时间片可以是10ms，20ms，30ms等等。</p>
<p>A：0时到达，需要工作时间5s</p>
<p>B：0时到达，需要工作时间5s</p>
<p>C：0时到达，需要工作时间5s</p>
<p>由于他们的耗时都一样，所以SJF和STCF是一样的效果，因此我们就把RR和SJF做比较。</p>
<p>SJF：</p>
<p>A：0～5</p>
<p>B：5～10</p>
<p>C：10～15</p>
<p>平均响应时间：（0+5+10）/3=5</p>
<p>1s时间片的RR：</p>
<p>A：0-1，3-4，6-7，9-10，12-13</p>
<p>B：1-2，4-5，7-8，10-11，13-14</p>
<p>C：2-3，5-6，8-9，11-12，14-15</p>
<p>平均响应时间：（0+1+2）/3=1</p>
<p><font color="indianred">时间片的长度对RR来说至关重要，越短，RR的表现越好。</font></p>
<p><font color="indianred">然而，时间片太短也有问题：频繁切换上下文的成本将影响整体性能。</font></p>
<p>因此，系统设计者需要权衡时间片的长短，在尽量短的同时，使其足够长，以便摊销上下文切换成本，而又不会使系统不及时响应。</p>
<p>举个例子，若切换上下文需要1ms，而时间片设置为10ms，那么也就是说10ms之后就要让下一个任务上来运行，所以在这之前就得切换，那么就要浪费1ms/10ms = 10%的时间用于切换上下文。（或者是10ms之后切换，那就是浪费下一个任务的时间，都一样）。但如果我们把时间片设置为100ms，那么只需要差不多1/100=1%的时间去切换上下文。</p>
<p>**<font color="indianred">上下文切换的成本</font>**不仅来自保存和恢复寄存器的操作系统操作。程序运行时，他们在CPU高速缓存、TLB、分支预测器和其他片上硬件中建立了大量的状态，切换到另一个工作会导致此状态被刷新，且与当前运行的作业相关的新状态被引入，这可能导致显著的性能成本。</p>
<ul>
<li><p>假如我们只考虑以响应时间是我们的唯一的指标，那么带有合理时间片的RR肯定是非常好的调度程序；</p>
</li>
<li><p>但是倘若以周转时间为指标，由于RR会让每个任务差不多都要到最后才能完成，毫无疑问RR是相当差劲的。事实上若以周转时间为指标，RR几乎是最差的，在很多情况下它甚至比FIFO还要更差。</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们称RR这样在较小时间内将CPU均匀分配到活动进程之间的策略成为公平的策略。</p>
<p>事实上，<font color="indianred">公平（响应时间）</font>与<font color="indianred">周转时间</font>是一对矛盾的存在。采用公平的策略，那周转时间就会被拉高；想让周转时间少，那响应时间则势必要上去了。</p>
<p>由于有这两种方面的需要，因此我们开发了两类调度程序，即前面说到的。</p>
<p>第一类，SJF，STCF优化周转时间，但对响应时间不利。</p>
<p>第二类，即RR，优化响应时间，但对周转时间不利。</p>
<h3 id="5-结合I-O"><a href="#5-结合I-O" class="headerlink" title="5.结合I/O"></a>5.结合I/O</h3><p>假设任务A有I/O操作，则我们可以在A进行I/O操作而进入阻塞态时，让任务B执行，等I/O操作结束后再让A进入就绪态，甚至是你也可以选择直接把B停下让A开始工作。</p>
<h3 id="我们还有一个问题没考虑，那就是我们常常在运行之前根本无法预料一个任务总共需要运行多长时间！"><a href="#我们还有一个问题没考虑，那就是我们常常在运行之前根本无法预料一个任务总共需要运行多长时间！" class="headerlink" title="我们还有一个问题没考虑，那就是我们常常在运行之前根本无法预料一个任务总共需要运行多长时间！"></a>我们还有一个问题没考虑，那就是我们常常在运行之前根本无法预料一个任务总共需要运行多长时间！</h3><h3 id="6-多级反馈队列（Muti-level-Feedback-Queue，MLFQ）"><a href="#6-多级反馈队列（Muti-level-Feedback-Queue，MLFQ）" class="headerlink" title="6.多级反馈队列（Muti- level Feedback Queue，MLFQ）"></a>6.多级反馈队列（Muti- level Feedback Queue，MLFQ）</h3><p>MLFQ希望解决两个问题：</p>
<ul>
<li>优化周转时间。</li>
<li>降低响应时间</li>
</ul>
<p>没错，他全都要！</p>
<p>我们知道像轮转这样的算法虽然降低了响应时间，但是周转时间很差；</p>
<p>而像SJF，STCF可以降低周转时间，但是响应时间很高。而且！我们通常不知道工作需要做多久，可这是SJF和STCF等算法所必需的。</p>
<p>🧠：问题来了，我们如何能在对进程一无所知的情况下去实现我们的调度目标呢？</p>
<p><font color="indianred">多级反馈队列的思路</font>是：利用历史经验来预测未来。通过在运行中学习进程的特征，从而做出更好的调度决策。</p>
<p>MLFQ中有许多独立的队列，每个队列有不同的优先级。任何时刻，一个工作只能存在于一个队列中，MLFQ总是执行优先级较高的工作，即在较高优先级的队列中的工作。</p>
<p>当然，每个队列中可能有多个工作，他们具有同样的优先级。我们对这些工作采用<font color="indianred">轮转</font>制度。</p>
<p>**<font color="indianred">MLFQ策略的关键</font>**载入如何设置优先级。MLFQ策略并不是让每个任务的优先级固定不变的，而是根据观察到的行为调整他的优先级。</p>
<p>例如，若一个工作不断地放弃CPU去等待键盘输入，这是交互型进程的可能行为，MLFQ会让它保持高优先级；因为他一会儿就放弃一下CPU，别的进程就有机会来执行了，所以把它保持在较高优先级，它有需要让它先执行，反正他一会儿就让出来了。</p>
<p>而若一个工作长时间占用CPU，MLFQ则会降低其优先级。</p>
<p>即我们有两类工作：</p>
<ul>
<li>既有运行时间很短，<font color="indianred">频繁放弃CPU的交互型工作</font>，</li>
<li>也有需要很多CPU时间，但响应时间却不重要的<font color="indianred">计算密集型工作</font>。</li>
</ul>
<p>MLFQ的基本规则：</p>
<ol>
<li><p>如果A的优先级 &gt; B的优先级，则运行A而不运行B</p>
</li>
<li><p>如果A的优先级 = B的优先级，则轮转运行A和B</p>
</li>
<li><p>一个工作刚进入系统时，总是先放在最高优先级队列中（最上层队列中）</p>
</li>
<li><p>如果一个工作用完了它在某一层中的时间配额（无论它中间主动放弃了多少次CPU），就降低其优先级（即移入低一级队列）。</p>
<ul>
<li>没有规则4，系统便有漏洞可钻，如果是当一个时间片用完便降级，那我完全可以在一个时间片用完之前主动放弃CPU，下次轮到我我又可以得到一个新的时间片，这样我就能一直身居高位了，这显然不行，因为这样其他工作岂不是得不到运行的机会了。</li>
</ul>
</li>
<li><p>经过一段时间S，我们就让所有工作重新进入最高优先级队列。</p>
<p>这个想法解决了两个问题：</p>
<ul>
<li>计算密集型工作饿死的问题。如果没有这条规则，那当系统中有太多交互型工作时就会不断占用CPU，导致长工作永远不会得到CPU，即称长工作饿死了。</li>
<li>一个进程在不同时间的表现可能不同，一个计算密集型进程可能在某个时候表现为交互型进程，若没有规则5，那么便没有机制让下层的任务得到去上层的机会，一个任务只有下降的份儿，而没有上升的份儿。</li>
</ul>
</li>
</ol>
<h3 id="7-比例份额（proportional-share）调度-公平份额（fair-share）调度"><a href="#7-比例份额（proportional-share）调度-公平份额（fair-share）调度" class="headerlink" title="7.比例份额（proportional- share）调度 / 公平份额（fair- share）调度"></a>7.比例份额（proportional- share）调度 / 公平份额（fair- share）调度</h3><p>比例份额的想法是：调用程序的最终目标，是确保每个工作获得一定比例的CPU时间，而不是优化周转时间和响应时间。</p>
<p>份额调度的经典例子即是彩票调度（lottery scheduling）。</p>
<p>彩票调度：每隔一段时间，都会举行一次彩票抽奖，以此来决定接下来应该运行那个进程。当然，我们希望越是应该频繁运行的程序，越是应该拥有更多的赢得彩票的机会。</p>
<p>最简单公平的方法就是随机抽彩票了，另一个方法就是步长调度。</p>
<h1 id="虚拟化内存（关于虚拟地址向物理地址映射的问题）"><a href="#虚拟化内存（关于虚拟地址向物理地址映射的问题）" class="headerlink" title="虚拟化内存（关于虚拟地址向物理地址映射的问题）"></a>虚拟化内存（关于虚拟地址向物理地址映射的问题）</h1><p>前面提到过<font color="indianred">虚拟化内存的目的——隔离</font>。</p>
<p>在时分共享系统中，进程切换时，我们将进程信息仍放在内存中，这样OS可以更有效率地实现时分共享。</p>
<p>我们的担忧是，当多个程序同时驻留在内存中，我们不希望一个进程能读取另一个进程的内存，更别说直接把另一个进程的信息给改掉了。</p>
<p>因此我们希望对每个进程进行保护，即隔离，以保证各个进程不受别的进程影响。</p>
<p>由于物理内存是一个共享空间，因此我们需要想办法提供一个<strong>物理内存的抽象</strong>——（<strong>虚拟）地址空间</strong>，让它成为运行的程序所看到的系统中的内存。</p>
<h2 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h2><p>一个进程的地址空间包含运行的程序的所有内存状态，如：</p>
<ul>
<li>程序的代码（或说指令）必须在内存中，因此它们在地址空间里；代码和字面常量放在代码区</li>
<li>程序运行时，利用栈来保存当前的函数调用信息，分配空间给局部变量，传递参数和函数返回值</li>
<li>堆则用于管理动态分配的、用户管理的内存，如用malloc和new申请空间</li>
<li>其他还有用来分配全局变量和静态变量的静态存储区等等。静态存储区分为 DATA 段和 BSS 段。DATA 段（全局初始化区）存放初始化的全局变量和静态变量；BSS 段（全局未初始化区）存放未初始化的全局变量和静态变量。</li>
</ul>
<h2 id="如何虚拟化内存"><a href="#如何虚拟化内存" class="headerlink" title="如何虚拟化内存"></a>如何虚拟化内存</h2><p>后面在描述地址空间时，都是指OS提供给运行程序的抽象，即虚拟地址空间。</p>
<p>如我们说当前程序的地址空间为0～16KB，并非指在物理内存中的0～16KB，<font color="indianred">他可能被载入到的是物理内存中的任意位置</font>。如此，我们便说操作系统在虚拟化内存，因为运行的程序以为它被加载到特定地址的内存中，并且拥有非常大的地址空间，但事实并不是这样。</p>
<p>具体来说，OS在专门硬件的帮助下，通过每一个虚拟内存的索引，将其转换为物理地址，物理内存根据所获取的物理地址去获取所需的信息。OS会同时对许多进程执行此操作，并且确保程序之间互相不会受到影响，当然也不会让它们影响到操作系统本身。</p>
<p>这就说明了我们的<font color="indianred">虚拟内存系统的一个主要目标——透明</font>。这里的透明不是说啥都一览无余，而恰恰相反，我们是希望一个进程好像看不见其他的进程一样。程序不应该感知到内存被虚拟化的事实，相反，程序的行为就好像他自己拥有自己的私有物理内存。在幕后，OS和硬件完成了所有的工作，让不同的工作能够复用内存。</p>
<p>下面具体来说其中的机制和策略。</p>
<h2 id="机制：地址转换"><a href="#机制：地址转换" class="headerlink" title="机制：地址转换"></a>机制：地址转换</h2><p>利用地址转换，硬件每次对内存访问进行处理（即指令获取、数据读取或写入），将指令中的虚拟地址转换为数据实际存储的物理地址。每次内存引用时，硬件都会进行地址转换，将应用程序的内存引用重定位到内存中的实际位置。当然<u>除了硬件，还需要OS在关键的位置介入</u>，设置好硬件才行，因此OS必须管理好内存，记录被占用和空闲的内存位置。</p>
<p>如此营造一种假象：每个程序都拥有私有的内存，里面存放着它自己的代码和数据。</p>
<p>现实是：许多程序其实是在同一时间共享着内存。</p>
<p>具体方法：<font color="indianred">基址加界限机制（动态重定位）</font>、<font color="indianred">分段</font>、<font color="indianred">分页</font></p>
<h3 id="基址加界限机制（动态重定位）"><a href="#基址加界限机制（动态重定位）" class="headerlink" title="基址加界限机制（动态重定位）"></a>基址加界限机制（动态重定位）</h3><p>每个CPU需要两个硬件寄存器：基址(base)寄存器和界限(bound)寄存器/限制(limit)寄存器。</p>
<p>其中基址为物理地址，而界限则是指我们在虚拟地址空间中的地址(或者说是偏移量吧这样好理解一点)；</p>
<p>那么便有：</p>
<p>实际物理地址 = 基地址 + 虚拟地址；</p>
<p>physical address = base + virtual address；</p>
<p>基址加界限机制会把每个虚拟地址给转换为物理地址，但其实如栈和堆之间就有大量空隙，那么把整片地址空间都给都给映射到物理地址上就会占用了很多物理地址，这显然是一种浪费。</p>
<h3 id="分段：泛化的基址-界限"><a href="#分段：泛化的基址-界限" class="headerlink" title="分段：泛化的基址/界限"></a>分段：泛化的基址/界限</h3><p>分段思想将在MMU(内存管理单元，Memory Mangement Unit)中引入不止一对基址、界限寄存器；而是为地址空间中的每个逻辑段都引入一对。</p>
<p>一个段只是地址空间中的一个<font color="indianred">连续定长的区域</font>（如下面代码段为2KB，堆段3KB，栈段2KB），</p>
<p>在典型的地址空间中有三个逻辑不同的段：代码、栈和堆。</p>
<p>分段思想让我们我们只将这些实际用到的空间投射到物理内存中去，以避免地址空间中未使用部分占用物理内存。</p>
<p>正是在支持分段的机器上，我们才看到了那个令C/C++程序员闻风丧胆的<font color="indianred">segmentation fault——段错误</font>，以及段异常(segmentation violation)。这通常是由于<font color="indianred">访问非法的地址</font>引起的。</p>
<p>举个例子：</p>
<p>有个地址空间中，</p>
<p>0～1KB：程序代码</p>
<p>2～4KB：空闲</p>
<p>4～6KB：堆</p>
<p>6～14KB：空闲</p>
<p>16～14KB：栈</p>
<p>那么利用分段机制，我们只将0～1KB，4～6KB，16～14KB给映射到物理内存中了。</p>
<p>☄️那么，当我们访问地址：7KB时，由于其无法映射到物理内存中，即它是一个非法地址，当你做出诸如此类的事情的时候机器便可能会告诉你：segmentation fault或是segmentation violation。</p>
<h4 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h4><p>当我们采用分段机制，硬件在地址转换时会使用到段寄存器，它保存了段标识和偏移量。</p>
<p>关于段标识：</p>
<p>我们在地址转换为实际物理地址的时候，由于采用了分段机制因此我们当然要知道当前地址在哪个段内以及偏移量是多少，这样才能去找物理地址中对应的这个段存储位置和实际物理地址。</p>
<p>段寄存器便采用了段标识来标记属于哪个段。</p>
<p>比如我们采用14位的虚拟地址，假如只有我们上面提到的代码、栈和堆这三个段，那么对于每一个虚拟地址我们可以用14位中的前两位来标识(00,01,10,11)当前的地址属于哪个段，即告诉硬件我们引用了哪个段，然后用后12位来标识段内偏移量。如下所示：</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/03/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/segment1.png" alt="segment1"></p>
<p>(当然这里有一个问题，由于我们只有三个段，但是有四个标识00,01,10,11，加入我们用的是前三个，那么显然11开头的地址就都被浪费了，因为不会有地址往哪里映射，因此有些系统中会把堆栈当作同一个段，这样我们只需要两种标识(0，1)，那用1位就可以了。)</p>
<p><font color="indianred">别忘了，分段机制还是基于基址界限方法，于是我们当然还是需要一个基址寄存器来记录当前段的基址。</font></p>
<p>于是我们来说两句题外话：</p>
<p>(这个不展开来说了，挖个坑，可以先参考</p>
<p> GDT详解：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zdwzzu2006/article/details/4030882">https://blog.csdn.net/zdwzzu2006/article/details/4030882</a></p>
<p>GDT与LDT：<a target="_blank" rel="noopener" href="https://blog.csdn.net/billpig/article/details/5833980">https://blog.csdn.net/billpig/article/details/5833980</a></p>
<p>GDT、GDTR、LDT、LDTR的学习：<a target="_blank" rel="noopener" href="https://blog.csdn.net/yeruby/article/details/39718119%EF%BC%88%E8%BF%99%E7%AF%87%E5%8F%82%E8%80%83%E4%BA%86%E5%89%8D%E4%B8%A4%E7%AF%87%EF%BC%89">https://blog.csdn.net/yeruby/article/details/39718119（这篇参考了前两篇）</a></p>
<p>)</p>
<h4 id="LDT表"><a href="#LDT表" class="headerlink" title="LDT表"></a>LDT表</h4><p>基址用LDT(局部描述符表，Local Description Table)来记录，对于每一个进程有一个LDT表，它记录了当前进程中每个段所在的物理位置。因为每个进程都有一张，这就是为啥叫做“局部进程表”。</p>
<p>那么我们该如何找到哪个进程该用哪张表呢？</p>
<h4 id="GDT表"><a href="#GDT表" class="headerlink" title="GDT表"></a>GDT表</h4><p>既然有局部的，那么自然就有全局的，我们称为GDT(全局描述符表，Global Description Table)，这意味着所有进程都可以看到这张表并访问它，以此得到我们需要的LDT表。</p>
<p>GDT表中，有着不同LDT表的地址(通过LDTR和selector得到)，如下图所示。</p>
<p>LDTR寄存器显示的就是当前LDT表的入口/起始地址。</p>
<p>GDTR寄存器则是保存了GDTR表的入口/起始地址。</p>
<p>下图表示了，我们可以通过GDTR找到GTD，再找到LDT的过程。</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/03/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/GDT_LDT.jpg" alt="GL1"></p>
<p>话锋一转，再回到分段上来。</p>
<p>当我们在当前进程的LDT表的帮助下得到了某个段的基地址，于是便可以由某个段的基地址和段寄存器中标识的偏移量得到实际的物理地址：（基址界限法）</p>
<p>物理地址 = 基地址 + 偏移量</p>
<p>在我们的例子中，在段寄存器中，除了对段标识占用的两位，剩下的14位显然也标识出了我们最大的偏移量。</p>
<p>偏移量简化了对段边界的判断，我们只要检查偏移量是否不超过界限即可，大于界限则为非法地址。</p>
<h4 id="分段的优点"><a href="#分段的优点" class="headerlink" title="分段的优点:"></a><font color="indianred">分段的优点:</font></h4><p>当我们原始的基址界限法的时候，我们将整块地址空间映射到了物理空间中，这样的糟糕之处在于地址空间中很多地方都没有用到，但他们映射后依然占着物理空间，这样别的进程就没法映射到这块物理地址上来，造成了极大的浪费。</p>
<p>这样地址空间内存在未用空间的现象中，我们称这些未用空间为内部碎片。</p>
<p>而分段方法则很好的解决了这个问题，因为它只将我们的各个段给映射了物理空间内，而那些我们还没想好该拿他们来干啥的空间(可以理解为还没开发的荒地)则不会被映射过去。</p>
<p><font color="indianred">但是请注意，由于段是定长的，所以每个段内部其实还是有尚未使用的空间的。每个段就像是一栋楼，这栋楼虽然是已经开发之地，明确了是用来住人的(就像是栈明确了是用来放局部变量、函数参数等信息的一样)，但里面当然也有还没人住的空房间。</font>所以“分段机制是我们用了多少就映射了多少”这种说法是不准确的。</p>
<h4 id="关于栈的偏移量"><a href="#关于栈的偏移量" class="headerlink" title="关于栈的偏移量"></a>关于栈的偏移量</h4><p>由于栈是反向增长的，因此我们没法直接用基址加上正向偏移量来算物理地址。</p>
<p>于是我们在段寄存器中增加一位判断反向的标记(0：自大而小增长,1自小而大增长)。</p>
<p>由此对栈偏移做出特殊处理；</p>
<p>举个例子，我们仍用段标识+偏移量我们仍用14位。</p>
<p>（书上表16.2可能会给你误导，让你以为段大小最多为2KB，但事实上英文版的书上表中“大小”两个字的旁边还写 (max 4K)，翻译没写上。。。当初看的时候很疑惑2KB的大小怎么下面算的时候还能有3KB的偏移呢？）</p>
<blockquote>
<p>说一下关于4K的问题，4K是指我们最多能为每个段分配4K的空间，而如2K则是我们现在实际为栈段分配的空间。所以我们是可以为段再分配空间的，因此可以有3KB的偏移。</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/03/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/fxzz.png" alt="fxzz"></p>
<p>而中文版的书上是这样的：(没错他还把堆的大小写错了，不知道是版本更新把错改过来了，还是就是中文版自己弄错了。原作者网站上一直保持最新版。看到3KB也不会想着段大小只有2KB了。。)</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/03/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/fxzz1.jpg" alt="fxzz1"></p>
<p>如我们访问的虚拟地址为15KB；</p>
<p>其二进制表示为：11 110000000000(共14位)</p>
<p>那么前两位为11，则我们知道它位于栈段</p>
<p>后面十二位为偏移量：110000000000即3KB。</p>
<p>那么由于标识了反向增长，则偏移量为3-4=-1KB或者你说反向偏移为-3KB那么-3+4=-1KB即正向看为正向偏移-1KB。</p>
<p>那么由于栈段基址为28KB，故我们的15KB的物理地址即为：</p>
<p>物理地址=基址+偏移量=28+（-1）=27KB。</p>
<p>算栈的时候由于偏移是负的，所以我们用偏移量的绝对值&lt;=段大小来判断未过界。</p>
<h4 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h4><p>为了节省内存，有些东西没必要每个进程都存一次，如代码在程序运行期间不会改变，因此代码在各个地址空间之间共享是很常见的。</p>
<p>不难想到，地址空间之间共享可能会破坏隔离，于是我们给段寄存器再加上一个保护位，来标识某一个段的读写执行权限。</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/03/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/wrx.png" alt="wrx"></p>
<p><font color="indianred">注意，这里堆段的权限为读和写，并不意味着其他地址空间的进程可以对这个地址空间的堆可以改写了。事实上，每个进程还是只能看见自己的地址空间，而共享的事情是操作系统在背后做的。一般操作系统只会让代码段在各个地址空间进行共享。这些保护位权限还是对当前进程来说的，他们能看到还是只有自己地址空间的东西，即这个进程看到“我只能对代码段读和执行啊”，那个进程看到的也是“我只能对代码段读和执行啊”，以此保证代码段内容不会被改掉。而堆栈这些操作系统根本不会让它在各个地址空间之间共享，因此每个进程读和改写的是这个进程的堆栈数据，而不会去改掉别的进程的数据</font></p>
<p>有了保护位，我们除了要检查界限，自然也要检查一下操作权限了。</p>
<h4 id="外部碎片"><a href="#外部碎片" class="headerlink" title="外部碎片"></a>外部碎片</h4><p>从前面所述，可以知道，我们为每个段分配的大小是不同的。于是当曾经被占用的内存被释放的时候，就会产生很多大小不一的空间片段。或许有很多这样的小片段，加起来有大很的空间，但是由于我们希望段是连续的空间，于是即使有这么大的空间也满足不了我们的分配要求。这种问题便是外部碎片问题了。</p>
<p>举个例子：</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/03/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/suipian.png" alt="suipian"></p>
<p>(图16.6:非紧凑和紧凑的内存)</p>
<p>左图中可以看到，我们还有8+8+8=24KB的空间空着(not in use)，但是如果我们现在想去为一个进程分配一个20KB的段却做不到，因为没有这样连续的20KB空间。这也是对空间的极大浪费。</p>
<p>一种方法是<font color="indianred">紧凑物理内存</font>，即在分配之前先终止现有进程，然后把他们的数据都复制到连续的一块内存区域去，但是拷贝段是内存密集型的人物，可想而知每次都这么弄，会占用大量的处理器时间，成本极高。</p>
<p>另一种简单的做法就是<font color="indianred">空闲列表管理算法</font>。</p>
<h4 id="空闲列表管理算法"><a href="#空闲列表管理算法" class="headerlink" title="空闲列表管理算法"></a><font color="indianred">空闲列表管理算法</font></h4><p>外部碎片的问题，不只是操作系统用分段的方式实现虚拟内存的时候有，使用用户级的内存分配库(如malloc和free函数)也会有。</p>
<p><font color="indianred">说在前面，空闲列表管理相关的算法可能有成百上千种，当时无论多么精妙都无法完全消除外部碎片</font>，所以可以把期待值降低一下，它没有你想的这么神奇。只要大小不一，就会有碎片，除非我们把分配的都是大小相同的。</p>
<p>下面主要从用户及内存分配库（malloc和free）出发来了解相关点，即在堆上管理空间。</p>
<p>(叫堆是历史原因，和数据结构中的堆不同)</p>
<p>在堆上管理空闲空间的数据结构通常称为空闲列表(free list)，该结构包含了所管理的内存区域中所有空闲块的引用。（空闲列表的具体数据结构不固定，只要能追踪空闲空间就行，如链表。）</p>
<h5 id="空闲列表的机制：分割与合并"><a href="#空闲列表的机制：分割与合并" class="headerlink" title="空闲列表的机制：分割与合并"></a>空闲列表的机制：分割与合并</h5><p><img src= "/img/loading.gif" data-lazy-src="/2020/03/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/space.png" alt="suipian"></p>
<p>对于这样一个堆(字节0～29)，空闲列表会记录如下：</p>
<p>即两块10个字节空闲空间：字节0～9和字节20～29.</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/03/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/freelist.png" alt="suipian"></p>
<p>那么现在我们可以知道，申请任何大于10字节的分配请求都会失败，因为没有大于10的连续可用空间。</p>
<p>如果我们要分配一个小于10的空间，则分配程序会执行一个<font color="indianred">分割</font>操作，如我们找到的是第二块空闲空间，要分配1个字节，那把字节20分配给他之后，空闲列表变成下面这样：</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/03/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/freelist1.png" alt="suipian"></p>
<p>另一个操作就是<font color="indianred">合并</font>。</p>
<p>还是看第一幅图，如现在三块空间全都放掉了，那么按理来说我们又拥有了30字节，但事实上我们得到的却是三块10个字节的空间，我们想要分配一块15字节的空间还是会失败。因此分配程序在释放一块内存的时候会合并可用空间，即在归还的时候检查一下与他相临的块是不是空闲状态，是那就把空闲列表变成这样(即合并为一个较大的块)：</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/03/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/freelist2.png" alt="suipian"></p>
<p>可以记得，<font color="indianred">在我们用free(p)的时候并没有块大小的参数，即我们不需要说我们释放了多大的空间，由此可知分配程序本身是可以很快知道要释放空间的大小的。</font></p>
<p>这是通过“头块”实现的，它一般在我们拿到的内存块之前，如图所示：</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/03/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/head.png" alt="suipian"></p>
<p>ptr指向的即是我们所申请内存的起始位置，在这块空间之前的那块便是头块(header)，这里面保存了一些东西，至少应该保存有我们所申请空间的大小。图中的magic叫幻数，它的作用是提供完整性检查(我也不知道具体怎么用)。</p>
<p><font color="indianred">由此，当用户申请N字节的内存时，库不是寻找N字节的空闲块，而是寻找N加上头块大小的空闲块；自然实际释放的也是分配的空间大小加上头块的大小。</font></p>
<h4 id="嵌入空闲列表"><a href="#嵌入空闲列表" class="headerlink" title="嵌入空闲列表"></a>嵌入空闲列表</h4><p>上面大概说了空闲列表的样子，知道表中节点可以带我们找到空闲空间，那么这个表是存在哪儿的呢？事实上，空闲列表往往本身就在我们所管理的空间内部。</p>
<p>假设我们要管理一块(下面的16KB是虚拟空间中这一块空间的起始地址)大小为4096字节的空间，那么我们先设置一个头块(8字节)，它记录了空闲空间的大小(size)和下一块空闲空间的位置（next），由于现在只有一块空闲空间，故next为NULL(这里写作0)：</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/03/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/insert1.png" alt="suipian"></p>
<p>(有一个空闲块的堆)</p>
<p>由此我们得到一块4088字节的空闲块。</p>
<p>下面我们要分配一块100字节的空间，则共需要准备108字节的空间(8字节作头块)，</p>
<p>由此现在我们的空间构成为(8+100)+(8+3980):</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/03/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/insert2.png" alt="suipian"></p>
<p>可以看到空闲列表的头块(head)(即空闲空前最前面那8个字节)里记录的size变为了3980，当然由于我们现在还是只有一块空闲空间，故next仍为0；</p>
<p>以此类推，我们再分配两块空间得到下图：</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/03/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/insert3.png" alt="suipian"></p>
<p>我们一共分配了三块100自己的空间，假如现在我们要释放掉其中第二块(即sptr指向的那块100字节的空间)已分配空间，</p>
<p>那么我们的库要做的便是将它释放掉，然后把这歌空闲块加回到空闲列表，这里我们可以采用头插法插到空闲列表的最前面，如下图：</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/03/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/insert4.png" alt="suipian"></p>
<p>可以看到这块新的空闲块处在了空闲列表的头位置，而他指向了另一块空闲块。</p>
<p>也就是说，我们现在一共有了两块空闲块，一块100字节，一块3764字节。</p>
<p>最后提醒一点，假设我们把另外两块也给释放了，而没做其他任何操作，那么我们又回到了之前说的问题，我们没有得到一块整空闲块，而是得到了四个空闲块。如下图所示：</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/03/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/insert5.png" alt="suipian"></p>
<p>故我们要遍历列表，合并相邻块，完成后，堆便又成了一个整体(整体是指我们查找的时候可以作为整体查找这片空闲空间，他自身一直都是整体)。</p>
<p>(事实上前面说过，合理的做法应该是是，每次释放时，我们就应该检查相邻空闲块块，并合并他们，因为<font color="indianred">空闲列表管理算法的目的就是试图尽量保留大的内存块用于分配。</font>)</p>
<h4 id="分配策略"><a href="#分配策略" class="headerlink" title="分配策略"></a>分配策略</h4><p>上面说了大致该怎么分配怎么释放，那么当我们的空间中有几块空闲块(即空闲列表不止一个节点)，我们该从哪块上面分配空间个申请者呢。</p>
<p>理想化的分配程序当然是希望速度又快，碎片又能最小化。但是由于分配和释放的请求的序列是任意的(谁知道用户什么时候想申请多大的空间，又会在什么时候把它释放掉呢？)，所以任何特定的策略都会有表现非常差的时候。故下面说的这些策略，我们不会去说有什么最好的策略，只是看看他们的优缺点罢了。</p>
<p><font color="indianred" size="5">最优匹配</font></p>
<p>遍历整个空闲列表，找到不小于申请大小的空闲块，然后选择其中最小的一个把用户需要的分配给他，剩下的留在空闲列表中。即找到一个最接近需求大小的块，尽量避免空间的浪费。</p>
<p>由于要遍历查找，所以要付出较高的性能代价。</p>
<p><font color="indianred" size="5">最差匹配</font></p>
<p>同样遍历，不过然后是找最大的块，分割满足用户的需求，然后将剩余的块留在空闲列表中。</p>
<p>最差匹配想的是，由于我找的是现有的最大的块，因此我分割完了之后还能将较大的块留在空闲列表中，而不是像最优匹配那样剩下很多难以利用的小块。</p>
<p>然后事实表明，最差匹配算法如其名，表现非常差，与他的理想背道而驰，会导致过量的碎片，同时还有很高的开销。</p>
<p><font color="indianred" size="5">首次匹配</font></p>
<p>找到第一个第一个够大的块，将请求的空间返回给用户，剩余的留在空闲列表，留给以后的请求。</p>
<p>这种方法不用每次遍历完整个列表，因而速度快一些，但是有时候会让列表开始的部分有很多小块。</p>
<p>怎么解决这些小块呢？当然是合并啦。</p>
<p>但是如果按照释放的顺序形成空闲列表，在堆中相邻的两块区域在列表中节点可能并不相邻。因此一个解决办法就是我们让空闲列表节点的顺序，一直和对应空闲块的地址顺序一致，这样找相邻块合并就会容易很多，从而减少了内存碎片。<font color="indianred">所以记住，我们说让相邻块合并，肯定是指实际相邻的空闲块，列表的相邻节点对应的空闲块并不一定相邻。</font>当然也可以想到，这样的按地址排序肯定也是耗时的。</p>
<p><font color="indianred" size="5">下次匹配</font></p>
<p>与首次匹配每次都从列表开头开始查找，而是多维护了一个指针，指向上一次查找结束的位置。这样做的好处是，我们会一直往下查找，将对空闲空间的查找操作扩散到了整个列表去，避免了对列表开头的地方频繁分割，堆积很多碎片。</p>
<p>这种策略的性能与首次匹配很接近，同样避免了遍历查找。</p>
<p>分段暂时告一段落，分离空闲列表、后块程序以及伙伴系统啥的以后再说。    [坑]</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>一下分段机制的优缺点：</p>
<p><font color="indianred" size="5">优点</font></p>
<p>除了和普通基址界限法一样的实现了动态重定位，还避免了地址空间的逻辑段之间大量潜在的内存浪费，分段能更好地支持稀疏地址空间。</p>
<p>分段要求的算法很容易，很适合硬件完成，因此很快，地址转换的开销极小。</p>
<blockquote>
<p>动态重定位是通过基址➕界限实现的，意思是有了基址我们可以根据不同的虚拟地址，将地址映射到不同的物理地址上。</p>
<p>稀疏地址空间简单理解就是存在很多空位/未用空间的地址空间，如果只用普通的基址界限法那就会产生很多内部碎片。</p>
</blockquote>
<p><font color="indianred" size="5">缺点</font></p>
<ul>
<li>由于我们给不同的段分配了不同大小的空间，于是物理内存中将会出现很多外部碎片，因此可能会让后面的申请变得困难。</li>
</ul>
<p>一种处理办法是定期紧凑内存，另一种办法是空闲列表管理法，但无论什么空闲列表管理办法都没办法彻底解决外部碎片问题。</p>
<ul>
<li>另一个问题是分段还是不足以支持更一般化的稀疏地址空间，如一个堆内也有可能是很稀疏的，但由于这些空间都在堆段内，因此整个堆仍然要完整地加载到内存中。</li>
</ul>
</div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Operating-System/">Operating System</a></div><div class="post_share"><div class="social-share" data-image="/2020/03/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/cover.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/03/20/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"><img class="prev-cover" data-lazy-src="/2020/03/20/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/cover.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">排序算法</div></div></a></div><div class="next-post pull-right"><a href="/2020/02/09/%E5%85%B3%E4%BA%8Ecpp%E7%B1%BB%E7%9A%84%E9%83%A8%E5%88%86%E7%82%B9/"><img class="next-cover" data-lazy-src="/2020/02/09/%E5%85%B3%E4%BA%8Ecpp%E7%B1%BB%E7%9A%84%E9%83%A8%E5%88%86%E7%82%B9/cover.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">关于C++类的部分点</div></div></a></div></nav></article></main><footer id="footer" style="background-image: url(/2020/03/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/top_img.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 江城子</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Thanks for visiting my <a target="_blank" rel="noopener" href="https://sosactwt.github.io/">page</a>!</div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  var script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>$(function () {
  $('span.katex-display').wrap('<div class="katex-wrap"></div>')
})</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>