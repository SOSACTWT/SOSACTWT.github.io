<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>关于C++类的部分点 | 大呓纪</title><meta name="description" content="关于cpp类的部分点类123class A&amp;#123;  ......&amp;#125;  成员 成员变量 成员函数 成员函数在类内声明，可以直接在类内定义， 也可以声明完了在类外通过类似于下面的这样来定义    123int A::get()&amp;#123;  .......&amp;#125;  public,private,protected 🧠C++的默认成员类型为private类型  public成员"><meta name="keywords" content="C++"><meta name="author" content="江城子"><meta name="copyright" content="江城子"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="http://yoursite.com/2020/02/09/%E5%85%B3%E4%BA%8Ecpp%E7%B1%BB%E7%9A%84%E9%83%A8%E5%88%86%E7%82%B9/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="yandex-verification" content="{&quot;theme_color&quot;:{&quot;enable&quot;:true,&quot;main&quot;:&quot;#49B1F5&quot;}}"/><meta property="og:type" content="article"><meta property="og:title" content="关于C++类的部分点"><meta property="og:url" content="http://yoursite.com/2020/02/09/%E5%85%B3%E4%BA%8Ecpp%E7%B1%BB%E7%9A%84%E9%83%A8%E5%88%86%E7%82%B9/"><meta property="og:site_name" content="大呓纪"><meta property="og:description" content="关于cpp类的部分点类123class A&amp;#123;  ......&amp;#125;  成员 成员变量 成员函数 成员函数在类内声明，可以直接在类内定义， 也可以声明完了在类外通过类似于下面的这样来定义    123int A::get()&amp;#123;  .......&amp;#125;  public,private,protected 🧠C++的默认成员类型为private类型  public成员"><meta property="og:image" content="http://yoursite.com/2020/02/09/%E5%85%B3%E4%BA%8Ecpp%E7%B1%BB%E7%9A%84%E9%83%A8%E5%88%86%E7%82%B9/cover.jpg"><meta property="article:published_time" content="2020-02-09T08:25:51.000Z"><meta property="article:modified_time" content="2021-04-10T11:46:18.855Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.0.2',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2021-04-10 19:46:18'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 5.0.2"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">10</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">13</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 基地</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 类别</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Ecpp%E7%B1%BB%E7%9A%84%E9%83%A8%E5%88%86%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">关于cpp类的部分点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98"><span class="toc-number">1.2.</span> <span class="toc-text">成员</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">1.3.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">构造函数与析构函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.1.</span> <span class="toc-text">构造函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">析构函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.</span> <span class="toc-text">拷贝构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%95%A5%E6%97%B6%E5%80%99%E4%BC%9A%E7%94%A8%E5%88%B0%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%91%A2%EF%BC%9F"><span class="toc-number">1.6.1.</span> <span class="toc-text">啥时候会用到拷贝构造函数呢？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%AF%B9%E8%B1%A1%E4%BB%A5%E5%80%BC%E4%BC%A0%E9%80%92%E7%9A%84%E6%96%B9%E5%BC%8F%E4%BC%A0%E5%85%A5%E6%9F%90%E4%B8%AA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">1、对象以值传递的方式传入某个函数参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%AF%B9%E8%B1%A1%E4%BB%A5%E5%80%BC%E4%BC%A0%E9%80%92%E7%9A%84%E6%96%B9%E5%BC%8F%E4%BB%8E%E6%9F%90%E4%B8%AA%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">2、对象以值传递的方式从某个函数返回</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%AF%B9%E8%B1%A1%E7%94%A8%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%9D%A5%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">3、对象用另一个对象来初始化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="toc-number">1.7.</span> <span class="toc-text">友元函数和友元类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.</span> <span class="toc-text">内联函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">1.9.</span> <span class="toc-text">静态成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.10.</span> <span class="toc-text">静态成员函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF-1"><span class="toc-number">1.11.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">1.11.1.</span> <span class="toc-text">多继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF"><span class="toc-number">1.11.2.</span> <span class="toc-text">虚拟继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">1.12.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%A3%E4%B9%88%E4%B8%BA%E5%95%A5%E7%94%A8%E7%88%B6%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%81%9A%E5%8F%82%E6%95%B0%E5%91%A2%E3%80%82"><span class="toc-number">1.12.1.</span> <span class="toc-text">那么为啥用父类对象做参数呢。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%A3%E4%B9%88%E4%B8%BA%E5%95%A5%E8%A6%81%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0%E5%91%A2%E3%80%82"><span class="toc-number">1.12.2.</span> <span class="toc-text">那么为啥要用虚函数呢。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.12.2.1.</span> <span class="toc-text">虚函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%A3%E4%B9%88%E4%B8%BA%E5%95%A5%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0%E5%91%A2%E3%80%82"><span class="toc-number">1.12.3.</span> <span class="toc-text">那么为啥构造函数不能用虚函数呢。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%A3%E4%B9%88%E4%B8%BA%E5%95%A5%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E8%A6%81%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0%E5%91%A2%E3%80%82"><span class="toc-number">1.12.4.</span> <span class="toc-text">那么为啥析构函数要用虚函数呢。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%9C%A8%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%8A%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.12.4.1.</span> <span class="toc-text">基类和派生类在析构函数上的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8A%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.12.4.2.</span> <span class="toc-text">基类和派生类在构造函数上的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.12.5.</span> <span class="toc-text">纯虚函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#extern"><span class="toc-number">1.13.</span> <span class="toc-text">extern</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static"><span class="toc-number">1.14.</span> <span class="toc-text">static</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">1.15.</span> <span class="toc-text">全局变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const"><span class="toc-number">1.16.</span> <span class="toc-text">const</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#const%E4%BF%AE%E9%A5%B0%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%8C%E5%88%99%E5%86%85%E5%AE%B9%E4%B8%BA%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%87%8F"><span class="toc-number">1.16.1.</span> <span class="toc-text">const修饰指针指向的内容，则内容为不可变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-%E4%BF%AE%E9%A5%B0%E6%8C%87%E9%92%88%EF%BC%8C%E5%88%99%E6%8C%87%E9%92%88%E4%B8%BA%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%87%8F%E3%80%82"><span class="toc-number">1.16.2.</span> <span class="toc-text">const 修饰指针，则指针为不可变量。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-%E4%BF%AE%E9%A5%B0%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%8C%E5%88%99%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%9A%84%E5%86%85%E5%AE%B9%E9%83%BD%E4%B8%BA%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%87%8F"><span class="toc-number">1.16.3.</span> <span class="toc-text">const 修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-%E4%BD%9C%E5%8F%82%E6%95%B0"><span class="toc-number">1.16.4.</span> <span class="toc-text">const 作参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-%E4%BF%AE%E9%A5%B0%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.16.5.</span> <span class="toc-text">const 修饰函数的返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-%E4%BF%AE%E9%A5%B0%E5%87%BD%E6%95%B0"><span class="toc-number">1.16.6.</span> <span class="toc-text">const 修饰函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%80%E4%BA%9B%E7%89%B9%E7%82%B9"><span class="toc-number">1.17.</span> <span class="toc-text">面向对象的一些特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">1.18.</span> <span class="toc-text">封装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF-2"><span class="toc-number">1.18.1.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81-1"><span class="toc-number">1.18.2.</span> <span class="toc-text">多态</span></a></li></ol></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(/2020/02/09/%E5%85%B3%E4%BA%8Ecpp%E7%B1%BB%E7%9A%84%E9%83%A8%E5%88%86%E7%82%B9/top_img.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">大呓纪</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 基地</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 类别</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">关于C++类的部分点</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2020-02-09T08:25:51.000Z" title="undefined 2020-02-09 16:25:51">2020-02-09</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>47分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="关于cpp类的部分点"><a href="#关于cpp类的部分点" class="headerlink" title="关于cpp类的部分点"></a>关于cpp类的部分点</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h2><ul>
<li>成员变量</li>
<li>成员函数<ul>
<li>成员函数在类内声明，可以直接在类内定义，</li>
<li>也可以声明完了在类外通过类似于下面的这样来定义</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">A::get</span><span class="params">()</span></span>&#123;</span><br><span class="line">  .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>public</code>,<code>private</code>,<code>protected</code></p>
<p><strong>🧠C++的默认成员类型为private类型</strong></p>
<ul>
<li>public成员 ,基类、派生类、友元、外部都可以访问</li>
<li>protected成员,基类、派生类、友元可以访问，</li>
<li>private成员,基类、友元可以访问，</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>有<code>public</code>,<code>private</code>,<code>protected</code>这三种方式的继承</p>
<p><strong>🧠C++的默认继承方式为private继承</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line">  .......</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">protected</span> A&#123;</span><br><span class="line">  .......</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">private</span> A&#123;</span><br><span class="line">  .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该图来自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/mu-ge/p/14523757.html">https://www.cnblogs.com/mu-ge/p/14523757.html</a></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/02/09/%E5%85%B3%E4%BA%8Ecpp%E7%B1%BB%E7%9A%84%E9%83%A8%E5%88%86%E7%82%B9/4.png" alt="img"></p>
<p>从物理结构上来说，子类确实包含了父类的私有成员，但是我们不能通过正常的渠道访问到他们。</p>
<p>我们可以通过内联汇编获取私有成员函数的入口地址，然后就能顺利访问了。</p>
<h2 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul>
<li>在每次创建类的新对象的时候执行</li>
<li>构造函数名称和类名完全一样，没有返回类型，也不是void。</li>
<li>我们可以用来为一些成员变量设置初值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      A()</span><br><span class="line">&#125;</span><br><span class="line">A::A()&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Object is being created, length = &quot;</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="green">按理来说构造函数也可以是私有的或是保护的，但是在创建一个对象的时候一定要是调用的公有构造函数，故下面这样会出错</font></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">protected</span>:<span class="comment">//写private也是一样出错</span></span><br><span class="line">    <span class="keyword">double</span> <span class="built_in">width</span>;</span><br><span class="line">    Box(<span class="keyword">double</span> wi)&#123;</span><br><span class="line">        <span class="built_in">width</span> = wi;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Box <span class="title">box</span><span class="params">(<span class="number">23.6</span>)</span></span>;<span class="comment">//创建一个对象的时候一定要是调用的公有构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于构造函数中的初始化（赋值）操作，我们可以简化为使用初始化列表来进行该字段的初始化操作</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">double</span> length;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      Line(<span class="keyword">double</span> len);</span><br><span class="line">&#125;</span><br><span class="line">Line::Line( <span class="keyword">double</span> len): length(len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Object is being created, length = &quot;</span> &lt;&lt; len &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">这等价于</span><br><span class="line">Line::Line( <span class="keyword">double</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    length = len;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Object is being created, length = &quot;</span> &lt;&lt; len &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>有多个字段，仍然可以这么做,不同字段用逗号隔开即可</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C::C( <span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> c): X(a), Y(b), Z(c)</span><br><span class="line">&#123;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="purple">关于创建对象，如果你的构造函数里面没有参数（包括使用默认的构造函数），那就别像<code>A a()</code>这样写了，因为这会让编译器认为你是在创建一个返回值为A类型的的无参函数a,我不知道是不是所有的都这样，但最好别这样写。</font></p>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><ul>
<li>它会在每次删除所创建的对象时执行</li>
<li>析构函数名称与类名相同，只是前面加了个～号作为前缀，没有返回值，也不能带任何参数。</li>
<li>析构函数有助于在跳出程序（比如关闭文件、释放内存等）之前释放资源</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setLength</span><span class="params">( <span class="keyword">double</span> len )</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getLength</span><span class="params">( <span class="keyword">void</span> )</span></span>;</span><br><span class="line">      Line();   <span class="comment">// 这是构造函数声明</span></span><br><span class="line">      ~Line();  <span class="comment">// 这是析构函数声明</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">double</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 成员函数定义，包括构造函数</span></span><br><span class="line">Line::Line(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Object is being created&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">Line::~Line(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Object is being deleted&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Line::setLength</span><span class="params">( <span class="keyword">double</span> len )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    length = len;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Line::getLength</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Line <span class="built_in">line</span>;</span><br><span class="line">   <span class="comment">// 设置长度</span></span><br><span class="line">   <span class="built_in">line</span>.setLength(<span class="number">6.0</span>); </span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Length of line : &quot;</span> &lt;&lt; <span class="built_in">line</span>.getLength() &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="keyword">is</span> being created</span><br><span class="line">Length of line : <span class="number">6</span></span><br><span class="line">Object <span class="keyword">is</span> being deleted</span><br></pre></td></tr></table></figure>

<p>🧠：<font size="4"><u>创建出来的对象(也是一个局部变量)是要保存在栈中的，因此由栈的先进后出，便可以知道，先创建的对象后析构；后创建的对象先析构</u></font></p>
<h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>类会有默认的拷贝构造函数</p>
<p>就类对象而言，相同类型的类对象是通过拷贝构造函数来完成整个复制过程的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#class CExample</span></span><br><span class="line"><span class="function">CExample <span class="title">A</span><span class="params">(<span class="number">100</span>)</span></span>;  </span><br><span class="line">CExample B = A; <span class="comment">//注意这里的对象初始化要调用拷贝构造函数，而非赋值  </span></span><br><span class="line">B.Show ();  </span><br></pre></td></tr></table></figure>

<ul>
<li><p>拷贝构造函数是一种<strong>特殊的构造函数</strong></p>
</li>
<li><p><strong>函数的名称必须和类名称一致，</strong></p>
</li>
<li><p><strong>它必须的一个参数是本类型的一个引用变量</strong></p>
<p>如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CExample</span> &#123;</span>  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="keyword">int</span> a;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="comment">//构造函数  </span></span><br><span class="line">    CExample(<span class="keyword">int</span> b)  </span><br><span class="line">    &#123; a = b;&#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//拷贝构造函数  </span></span><br><span class="line">    CExample(<span class="keyword">const</span> CExample&amp; C)  </span><br><span class="line">    &#123;  </span><br><span class="line">        a = C.a;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//一般函数  </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span> <span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="function">CExample <span class="title">A</span><span class="params">(<span class="number">100</span>)</span></span>;  </span><br><span class="line">    CExample B = A; <span class="comment">// CExample B(A); 也是一样的  </span></span><br><span class="line">     B.Show ();  </span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="啥时候会用到拷贝构造函数呢？"><a href="#啥时候会用到拷贝构造函数呢？" class="headerlink" title="啥时候会用到拷贝构造函数呢？"></a>啥时候会用到拷贝构造函数呢？</h3><h4 id="1、对象以值传递的方式传入某个函数参数"><a href="#1、对象以值传递的方式传入某个函数参数" class="headerlink" title="1、对象以值传递的方式传入某个函数参数"></a>1、<strong>对象以值传递的方式传入某个函数参数</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如定义这个全局函数(即类外函数)，传入的是对象  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g_Fun</span><span class="params">(CExample C)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;test&quot;</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">那么</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"> <span class="function">CExample <span class="title">test</span><span class="params">(<span class="number">1</span>)</span></span>;  </span><br><span class="line"> <span class="comment">//传入对象  </span></span><br><span class="line"> g_Fun(test);  <span class="comment">//这里将一个对象test传入时，就会调用拷贝构造函数</span></span><br><span class="line">  </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>具体来说：</p>
<p>调用g_Fun()时，会产生以下几个重要步骤：</p>
<ul>
<li>test对象传入形参时，会先会产生一个临时变量，就叫 C 吧。</li>
<li>然后调用拷贝构造函数把test的值给C。 整个这两个步骤有点像：CExample C(test);</li>
<li>等g_Fun()执行完后(但是在函数退出之前), 析构掉对象C。</li>
</ul>
</li>
</ul>
<h4 id="2、对象以值传递的方式从某个函数返回"><a href="#2、对象以值传递的方式从某个函数返回" class="headerlink" title="2、对象以值传递的方式从某个函数返回"></a>2、<strong>对象以值传递的方式从某个函数返回</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CExample <span class="title">g_Fun</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"> <span class="function">CExample <span class="title">a</span><span class="params">(<span class="number">0</span>)</span></span>;  </span><br><span class="line"> <span class="keyword">return</span> a;  <span class="comment">//（🍎）</span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（🍎）：</p>
<p>当func()函数执行到return时，会产生以下几个重要步骤：</p>
<ul>
<li>先会产生一个临时变量，就叫temp吧。</li>
<li>然后调用拷贝构造函数把a的值给temp。整个这两个步骤有点像：CExample temp(a);</li>
<li>在函数执行到最后先析构a局部变量。</li>
<li>等g_Fun()执行完退出后再析构掉temp对象。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Line <span class="title">func</span><span class="params">(Line b)</span></span>&#123;<span class="comment">//调用拷贝构造函数1</span></span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;“hello”&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="keyword">return</span> b;<span class="comment">//(🧠)//调用拷贝构造函数2</span></span><br><span class="line"> &#125;</span><br><span class="line">调用拷贝构造函数<span class="number">1</span></span><br><span class="line">调用拷贝构造函数<span class="number">2</span></span><br><span class="line">为参数对象调用析构函数</span><br><span class="line">函数退出，为(🧠)处产生的临时变量调用析构函数</span><br></pre></td></tr></table></figure>

<p><font color="indianred">关于参数对象(b)，局部对象(a)，临时对象(temp)的析构顺序：</font></p>
<p><font color="indianred">参数对象(b)，局部对象(a)在函数退出之前析构；</font></p>
<p><font color="indianred">且局部对象先析构，参数对象后析构</font></p>
<p><font color="indianred">而return处产生的临时对象则是在函数调用完成退出之后才调用析构函数的。</font></p>
<h4 id="3、对象用另一个对象来初始化"><a href="#3、对象用另一个对象来初始化" class="headerlink" title="3、对象用另一个对象来初始化"></a>3、对象用另一个对象来初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CExample <span class="title">A</span><span class="params">(<span class="number">100</span>)</span></span>;  </span><br><span class="line">CExample B = A; <span class="comment">//产生一个临时变量C，将A拷贝给C，再进入B的构造函数C将C的各变量赋给B</span></span><br><span class="line"><span class="comment">// CExample B(A);  这样写也可以 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="友元函数和友元类"><a href="#友元函数和友元类" class="headerlink" title="友元函数和友元类"></a>友元函数和友元类</h2><p>友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。</p>
<p>类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">double</span> <span class="built_in">width</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">double</span> length;</span><br><span class="line">   <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">printWidth</span><span class="params">( Box box )</span></span>;</span><br><span class="line">   <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">BigBox</span>;</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">( <span class="keyword">double</span> wid )</span></span>;</span><br><span class="line">  <span class="comment">//声明类 ClassTwo 的所有成员函数作为类 ClassOne 的友元，需要在类 ClassOne 的定义中放置如上声明.</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BigBox</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> <span class="built_in">width</span>, Box &amp;box)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// BigBox是Box的友元类，它可以直接访问Box类的任何成员</span></span><br><span class="line">        box.setWidth(<span class="built_in">width</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Width of box : &quot;</span> &lt;&lt; box.<span class="built_in">width</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Box::setWidth</span><span class="params">( <span class="keyword">double</span> wid )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">width</span> = wid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 请注意：printWidth() 不是任何类的成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printWidth</span><span class="params">( Box box )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/* </span></span><br><span class="line"><span class="comment">   因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 ，如这里直接访问私有变量width</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Width of box : &quot;</span> &lt;&lt; box.<span class="built_in">width</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Box box;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 使用成员函数设置宽度</span></span><br><span class="line">   box.setWidth(<span class="number">10.0</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 使用友元函数输出宽度</span></span><br><span class="line">   printWidth( box );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 使用友元类中的方法设置宽度</span></span><br><span class="line">   big.Print(<span class="number">20</span>, box);</span><br><span class="line">  </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为友元函数没有this指针，则参数要有三种情况： </p>
<p>要访问非static成员时，需要对象做参数；</p>
<p>要访问static成员或全局变量时，则不需要对象做参数；</p>
<p>如果做参数的对象是全局对象，则不需要对象做参数.</p>
<p>可以直接调用友元函数，不需要通过对象或指针</p>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>引入内联函数的目的是为了解决程序中函数调用的效率问题，这么说吧，程序在编译器编译的时候，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体进行替换，而对于其他的函数，都是在运行时候才被替代。这其实就是个空间代价换时间的节省。所以内联函数一般都是1-5行的小函数。在使用内联函数时要留神：</p>
<ul>
<li>1.在内联函数内不允许使用循环语句，switch语句，异常接口声明；</li>
<li>2.内联函数的定义必须出现在内联函数第一次调用之前；</li>
<li>3.对于类的成员函数，在类内定义则默认为内联函数，但是类成员函数也可以再类外定义，故==成员函数不一定是内联函数==。</li>
<li>递归函数(自己调用自己的函数)是不<em>能</em>被用来做<em>内联函数的</em></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><span class="comment">//内联函数用inline关键字</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (x &gt; y)? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h2><p>我们可以使用 <strong>static</strong> 关键字来把类成员定义为静态的。当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本(或者说在内存中只有一份拷贝)，为这个类的所有对象所共享，即一处变处处变。</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/02/09/%E5%85%B3%E4%BA%8Ecpp%E7%B1%BB%E7%9A%84%E9%83%A8%E5%88%86%E7%82%B9/3.png" alt="img"></p>
<p>静态成员在类的所有对象中是共享的。</p>
<p><font color="indianred">静态变量必须要经过初始化才能使用，且只能在类外初始化。</font>写为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> A::m=<span class="number">9</span>;<span class="comment">//对静态成员变量的初始化</span></span><br><span class="line"><span class="comment">//如果这里不赋初值，写作int A::m = 9 ,则默认初始化为0.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A::output</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;m&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  A apple;</span><br><span class="line">  apple.output();</span><br><span class="line">&#125;<span class="comment">//9</span></span><br></pre></td></tr></table></figure>

<p>我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 <strong>::</strong> 来重新声明静态变量从而对它进行初始化，如下面的实例所示。</p>
<h2 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h2><p>如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，<strong>静态函数</strong>只要使用类名加范围解析运算符 <strong>::</strong> 就可以访问。</p>
<p>静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数。</p>
<p><font color="indianred">因为静态成员函数属于整个类，在类实例化对象之前就已经分配空间了，而类的非静态成员必须在类实例化对象后才有内存空间，所以在静态成员函数内使用非静态资源就出错了，就好比没有声明一个变量却提前使用它一样。</font></p>
<p>静态成员函数有一个类范围，他们不能访问类的 this 指针。您可以使用静态成员函数来判断类的某些对象是否已被创建。</p>
<blockquote>
<p><strong>静态成员函数与普通成员函数的区别：</strong></p>
<ul>
<li>静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。</li>
<li>普通成员函数有 this 指针，可以访问类中的任意成员；</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">int</span> objectCount;</span><br><span class="line">      <span class="comment">// 构造函数定义</span></span><br><span class="line">      Box(<span class="keyword">double</span> l=<span class="number">2.0</span>, <span class="keyword">double</span> b=<span class="number">2.0</span>, <span class="keyword">double</span> h=<span class="number">2.0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;Constructor called.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">         length = l;</span><br><span class="line">         breadth = b;</span><br><span class="line">         <span class="built_in">height</span> = h;</span><br><span class="line">         <span class="comment">// 每次创建对象时增加 1</span></span><br><span class="line">         objectCount++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">Volume</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> length * breadth * <span class="built_in">height</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> objectCount;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">double</span> length;     <span class="comment">// 长度</span></span><br><span class="line">      <span class="keyword">double</span> breadth;    <span class="comment">// 宽度</span></span><br><span class="line">      <span class="keyword">double</span> <span class="built_in">height</span>;     <span class="comment">// 高度</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 初始化类 Box 的静态成员</span></span><br><span class="line"><span class="keyword">int</span> Box::objectCount = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 在创建对象之前输出对象的总数</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Inital Stage Count: &quot;</span> &lt;&lt; Box::getCount() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="function">Box <span class="title">Box1</span><span class="params">(<span class="number">3.3</span>, <span class="number">1.2</span>, <span class="number">1.5</span>)</span></span>;    <span class="comment">// 声明 box1</span></span><br><span class="line">   <span class="function">Box <span class="title">Box2</span><span class="params">(<span class="number">8.5</span>, <span class="number">6.0</span>, <span class="number">2.0</span>)</span></span>;    <span class="comment">// 声明 box2</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 在创建对象之后输出对象的总数</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Final Stage Count: &quot;</span> &lt;&lt; Box::getCount() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Inital Stage Count: 0</span></span><br><span class="line"><span class="comment">Constructor called.</span></span><br><span class="line"><span class="comment">Constructor called.</span></span><br><span class="line"><span class="comment">Final Stage Count: 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h2><p>一个派生类继承了所有的基类方法，但下列情况除外：</p>
<ul>
<li>基类的构造函数、析构函数和拷贝构造函数。</li>
<li>基类的重载运算符。</li>
<li>基类的友元函数。</li>
</ul>
<p>当一个类派生自基类，该基类可以被继承为 <strong>public、protected</strong> 或 <strong>private</strong> 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。</p>
<p>我们几乎不使用 <strong>protected</strong> 或 <strong>private</strong> 继承，通常使用 <strong>public</strong> 继承。当使用不同类型的继承时，遵循以下几个规则：</p>
<ul>
<li><strong>公有继承（public）：</strong>当一个类派生自<strong>公有</strong>基类时，基类的<strong>公有</strong>成员也是派生类的<strong>公有</strong>成员，基类的<strong>保护</strong>成员也是派生类的<strong>保护</strong>成员，基类的<strong>私有</strong>成员不能直接被派生类访问，但是可以通过调用基类的<strong>公有</strong>和<strong>保护</strong>成员来访问。</li>
<li><strong>保护继承（protected）：</strong> 当一个类派生自<strong>保护</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>保护</strong>成员。</li>
<li><strong>私有继承（private）：</strong>当一个类派生自<strong>私有</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>私有</strong>成员。</li>
</ul>
<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类 Shape</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="built_in">width</span> = w;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="built_in">height</span> = h;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">int</span> <span class="built_in">width</span>;</span><br><span class="line">      <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 基类 PaintCost</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaintCost</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getCost</span><span class="params">(<span class="keyword">int</span> area)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> area * <span class="number">70</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape, <span class="keyword">public</span> PaintCost</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         <span class="keyword">return</span> (<span class="built_in">width</span> * <span class="built_in">height</span>); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Rectangle Rect;</span><br><span class="line">   <span class="keyword">int</span> area;</span><br><span class="line"> </span><br><span class="line">   Rect.setWidth(<span class="number">5</span>);</span><br><span class="line">   Rect.setHeight(<span class="number">7</span>);</span><br><span class="line"> </span><br><span class="line">   area = Rect.getArea();</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 输出对象的面积</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Total area: &quot;</span> &lt;&lt; Rect.getArea() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 输出总花费</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Total paint cost: $&quot;</span> &lt;&lt; Rect.getCost(area) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Total area: 35</span></span><br><span class="line"><span class="comment">Total paint cost: $2450</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="虚拟继承"><a href="#虚拟继承" class="headerlink" title="虚拟继承"></a>虚拟继承</h3><p>菱形继承：菱形继承是多继承的一种特殊情况。有两个子类继承同一个父类，而又有子类同时继承这两个子类。</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/02/09/%E5%85%B3%E4%BA%8Ecpp%E7%B1%BB%E7%9A%84%E9%83%A8%E5%88%86%E7%82%B9/2.png" alt="img"></p>
<p>通过上面的图可以看出菱形继承有<strong>数据冗余和二义性</strong>的问题，在Assistant的对象中Person成员会有两份。</p>
<p>以学生老师和课程三个关系为例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> _name; <span class="comment">// 姓名 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person</span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line">    <span class="keyword">int</span> _num ; <span class="comment">//学号 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> :</span> <span class="keyword">public</span> Person </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span> :    </span><br><span class="line">    <span class="keyword">int</span> _id ;<span class="comment">// 职工编号 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Assistant</span> :</span> <span class="keyword">public</span> Student, <span class="keyword">public</span> Teacher</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line">    <span class="built_in">string</span> _majorCourse ; <span class="comment">// 主修课程 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     </span><br><span class="line">    Assistant a ;</span><br><span class="line">    a._name = <span class="string">&quot;Tom&quot;</span>;<span class="comment">//这样会有二义性，无法明确知道访问的是Student的成员还是Teacher的成员   </span></span><br><span class="line">    <span class="comment">// 需要显示指定访问哪个父类的成员可以解决二义性问题，但是数据冗余问题无法解决 </span></span><br><span class="line">    a.Student::_name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">    a.Teacher::_name = <span class="string">&quot;peter&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为了解决菱形的二义性和数据冗余问题就引出了虚拟继承，在上述代码Student和Teacher继承Person时使用虚拟继承，只需要在public前加上virtual即可。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> _name; <span class="comment">// 姓名 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span><span class="keyword">virtual</span> <span class="keyword">public</span> Person</span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line">    <span class="keyword">int</span> _num ; <span class="comment">//学号 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> :</span><span class="keyword">virtual</span> <span class="keyword">public</span> Person </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span> :    </span><br><span class="line">    <span class="keyword">int</span> _id ;<span class="comment">// 职工编号 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Assistant</span> :</span> <span class="keyword">public</span> Student, <span class="keyword">public</span> Teacher</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line">    <span class="built_in">string</span> _majorCourse ; <span class="comment">// 主修课程 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Assistant a;</span><br><span class="line">    a._name = <span class="string">&quot;小明&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态就是说不同继承关系的类对象去调用同一个函数，可以产生不同的行为（通俗来说父亲和孩子都会说话，父亲.say()得到的是成熟的声音；而孩子.say()得到的奶气的声音。）</p>
<p>多态一般通过子类重写父类的虚函数virtual int F(int a,char b){…..}实现，</p>
<p>重写即就是子类的里这个函数的名称，参数，返回类型都必须和父类里的完全一样。</p>
<p>由此实现多态。</p>
<p><u>在子类里的F前面也可以把virtual写上，但是不写也行，因为父类中一个函数被声明为虚函数，那么在所有的派生类中它都是虚函数了。</u></p>
<p>构成多态有两点必要的：</p>
<ul>
<li><font color="idiablue">调用该函数的必须是指针或者引用；</font></li>
<li><font color="idiablue">被调用的函数必须是虚函数，且完成了虚函数的重写，即上面说的</font>。</li>
</ul>
<p><font color="indianred">这两个条件必要同时满足</font></p>
<p>下面分别解释：（父类Parent，子类Child，方法F）</p>
<p><font color="indianred">那么为啥调用该函数的必须是指针或者引用呢。</font></p>
<p>开门见山：为了动态绑定，动态绑定只有当我们通过指针或引用调用虚函数的时候才会发生。</p>
<p>先来看一个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuyTicket</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Adult need Full Fare!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuyTicket</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Child Free!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(Parent obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj.BuyTicket(); <span class="comment">//直接拿对象去调用这个虚函数                                                                                                                            </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Parent p;</span><br><span class="line">    Child c;</span><br><span class="line">    fun(p);</span><br><span class="line">    fun(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Adult need Full Fare!</span></span><br><span class="line"><span class="comment">//Adult need Full Fare!(🍎)</span></span><br></pre></td></tr></table></figure>

<p>可以看到虽然用了虚函数，但是如果我们直接拿对象去调用这个虚函数BuyTicket，那么调用是有问题的。</p>
<blockquote>
<p>解释一下什么是静态和动态类型，如对于F(Parent &amp;obj)（或是*obj）</p>
<ul>
<li><p>静态类型你可以理解为obj本身的类型，即父亲类对象的引用，Parent&amp;，它是父亲类型的</p>
</li>
<li><p>而动态类型，则依赖于obj最后传入的到底是什么类型</p>
<ul>
<li><p>​    如传入p，即传入的是父亲类型的对象，父亲类型便是obj此时的动态类型</p>
<p>​    那调用BuyTicket的就是父类对象，自然用父类的成员函数</p>
</li>
<li><p>而传入c，即传入的是孩子类型的对象，孩子类型便是obj此时的动态类型</p>
<p>那调用BuyTicket的就是子类对象，自然用孩子类的成员函数</p>
</li>
</ul>
</li>
<li><p>动态类型通过指针或引用实现，即这个指针(或引用)最终真正指向的区域是什么类型的对象。而这个指向在我们真正将具体对象传入之前，是无法得知的，即这个参数对象最终和哪个类绑定得真正执行的时候才知道。故这样的操作也称动态绑定。</p>
</li>
</ul>
</blockquote>
<p>因为（无论是对非虚函数的调用还是，还是）直接通过对象进行的函数（虚函数或非虚函数）的调用都是在编译时绑定的。而对象的类型没法改变的，我们无法让一个对象的动态类型和静态类型不一致。因此，通过对象进行的函数调用将在编译时就绑定到该对象所属类的那个版本的函数上。用这个例子来看就是：</p>
<p>参数为：Parent obj，即一个父类的对象，(后面解释为什么用父类做参数)</p>
<p>那</p>
<p>在编译时读取到：obj.BuyTicket()这句话便认为我们将要调用的是一个父类成员方法了。</p>
<p>因此最后就产生了上面🍎处的结果。</p>
<h3 id="那么为啥用父类对象做参数呢。"><a href="#那么为啥用父类对象做参数呢。" class="headerlink" title="那么为啥用父类对象做参数呢。"></a><font color="indianred">那么为啥用父类对象做参数呢。</font></h3><p>因为只能是派生类给基类赋值，会发生切片操作。基类不能给派生类赋值。</p>
<p>简单理解就是派生类可以强转为基类，但是基类默认不可以转成派生类。</p>
<p>故若用子类做参数，那我们就无法正确将父类对象传进去了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(Child *obj)</span><span class="comment">//以子类对象作为参数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj-&gt;BuyTicket();                                                                                                                             </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person *p;</span><br><span class="line">    Child *c;</span><br><span class="line"></span><br><span class="line">    fun(p);<span class="comment">//这里便会出错</span></span><br><span class="line">    fun(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> cannot convert from base class pointer &#x27;Person *&#x27;</span></span><br><span class="line"><span class="comment">to derived class pointer &#x27;Child *&#x27; for 1st argument</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>上面说了用指针或是引用是为了动态绑定。</p>
<blockquote>
<p>C++primer ch15.3,也有描述</p>
<p>当且仅当通过指针或者引用调用虚函数时，才会在运行时解析该调用，也只有这种情况下，对象的动态类型才有可能与静态类型不同。</p>
</blockquote>
<h3 id="那么为啥要用虚函数呢。"><a href="#那么为啥要用虚函数呢。" class="headerlink" title="那么为啥要用虚函数呢。"></a><font color="indianred">那么为啥要用虚函数呢。</font></h3><h4 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h4><p>即为在函数最前面加上了关键字<code>virtual</code>的函数，虚函数只在类中使用。</p>
<p>编译器为每个类添加了一个隐藏成员，隐藏成员中保存了一个指向虚函数地址数组的指针，称为虚表指针(vptr)，这种数组称为虚函数表(virtual function table，vtbl),故</p>
<p>有虚函数的类就会有一张虚函数表，而每个类的对象则会用一个虚表指针指向该虚函数表。</p>
<p>如果派生类重写了基类的虚函数，那么派生类中将保存的应该是重写的虚函数的地址，而不是基类的虚函数地址。</p>
<p>而如果派生类没有重写而是直接继承了基类的虚函数，那么派生类中虚函数表将保存基类中未被重写的虚函数。</p>
<p>当然如果子类中还定义了新的虚函数，这个虚函数的地址也会被添加到派生类的虚函数表中。</p>
<p>由此我们知道经过重写时候，有两张不一样的表，</p>
<p>于是当我们调用函数的时候会发生语法检查，当我们在运行时将子类对象指针/引用传入之后（即满足多态条件）便会去查找子类虚表中虚函数的对应地址，于是即去调用了子类中重写过的那个虚函数；而如果传入的是父类对象指针/引用，那自然是去父类虚函数表找对应的虚函数地址，即去调用父类中那个虚方法了。</p>
<p>再提一遍，如果我们不使用指针或引用，而是直接用对象parent obj做参数，那在编译阶段，便会根据参数绑定到父类中的那个虚函数上去，即最后调用的必然是父类虚函数了。</p>
<p>总的来说指针/引用和虚函数都是必须的，不用虚函数的话，也无法实现动态绑定，而编译器则采用静态绑定，即根据这个指针本身的类别来判断，那在这里自然最后调用的是父类虚函数了。</p>
<h3 id="那么为啥构造函数不能用虚函数呢。"><a href="#那么为啥构造函数不能用虚函数呢。" class="headerlink" title="那么为啥构造函数不能用虚函数呢。"></a><font color="indianred">那么为啥构造函数不能用虚函数呢。</font></h3><p>我们知道虚函数的使用主要起到了动态绑定的效果，即我们只需知道这个接口(即这个虚函数)而无需知道具体的类型，等到这个虚函数运行时再根据具体传入类型去调用具体的虚函数。即虚函数行为是在运行期间确定实际类型的。</p>
<p>而对于构造函数来说，当我们创建一个对象我们必须知道一个对象具体的类型才能去把这个类型的对象给创建出来，那如果构造函数是一个虚函数，我们则需要在调用他的时候根据传入对象类型去传入一个“实际的类型”去调用正确的构造函数，然而此时我们的对象还未构建成功，编译器无法得知对象的实际类型，那自然是无法去调用所谓正确的构造函数(虚函数)的，这就形成了一个<font color="indianred">悖论</font>。</p>
<h3 id="那么为啥析构函数要用虚函数呢。"><a href="#那么为啥析构函数要用虚函数呢。" class="headerlink" title="那么为啥析构函数要用虚函数呢。"></a><font color="indianred">那么为啥析构函数要用虚函数呢。</font></h3><p>当对象的生命周期结束时，我们需要用到析构函数。</p>
<p>虚析构函数是为了解决这样的一个问题：基类的指针指向派生类对象，并用基类的指针删除派生类对象。</p>
<ul>
<li><p>对于不用被继承的类来说，析构函数是不是虚函数自然无所谓。因此C++默认的析构函数并不是虚函数，虚函数表以及虚表指针都会耗费更多的空间。</p>
</li>
<li><p>而在类的继承中，</p>
<ul>
<li><p>其实如果是派生类的指针指向派生类的对象，那析构自然没什么问题，是不是虚函数都可以去完成正确的析构操作。</p>
</li>
<li><p>然而假如有基类的指针去指向了派生类的对象，那么当我们去执行析构操作的时候，就涉及到了一个<font color="indianred">“该调用基类析构函数还是派生类析构函数的问题”</font>了.这就回到了我们上面讨论的虚函数在类继承和多态中的作用了。</p>
<p>因此可以知道假如我们的析构函数不用虚函数，那么编译器便实施静态绑定，在删除基类指针的时候只会去调用基类的析构函数，而不调用派生类的析构函数。</p>
<p>而当我们使用了虚析构函数，我们便可以调用到派生类的析构函数，<font color="indianred" size="5">而且</font><font color="indianred">，另外还有派生类的析构函数会自动调用基类的析构函数(在下面说为啥)这样一条机制，我们便能够做到把和基类与派生类相关的占用的内存都给清理干净了。</font></p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span>~A()&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Delete class APn&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~B()&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Delete class BPn&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A *a=<span class="keyword">new</span> B;<span class="comment">//即a是一个基类指针，但是指向了派生类对象</span></span><br><span class="line"><span class="keyword">delete</span> a;<span class="comment">//我们删除这个基类指针，以此删除那个派生类对象</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//由于派生类析构函数会自动调用基类析构函数，且是先调用派生类的再调用基类的，因此我们会得到：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Delete class BPn</span></span><br><span class="line"><span class="comment">Delete class APn</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>而如果我们不用虚函数，则会得到</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Delete class APn</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><font color="indianred">这里其实还有额外一个问题：为啥默认派生类的析构函数要自动调用基类的析构函数呢？</font></p>
<h4 id="基类和派生类在析构函数上的关系"><a href="#基类和派生类在析构函数上的关系" class="headerlink" title="基类和派生类在析构函数上的关系"></a><font color="indianred">基类和派生类在析构函数上的关系</font></h4><p>不要认为上面是因为先创建了基类指针才导致的最后调用了基类析构，事实上，即使我们只是这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  B b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后的输出结果仍然是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Delete <span class="class"><span class="keyword">class</span> <span class="title">BPn</span></span></span><br><span class="line"><span class="class"><span class="title">Delete</span> <span class="title">class</span> <span class="title">APn</span></span></span><br></pre></td></tr></table></figure>

<p><font color="indianred">解答：这是因为事实上，派生类包含了两个部分，基类部分和派生类部分，基类部分和派生类部分，因此当我们需要做清理工作的时候，不仅要清理派生类部分相关的内存，还要做基类部分的清理工作。<br>且内存的清理工作必须严格要求，谁开辟的谁最后释放，因此我们两部分的析构函数都要调用。</font></p>
<p>既然看到了析构函数，那么不难联想到:</p>
<h4 id="基类和派生类在构造函数上的关系"><a href="#基类和派生类在构造函数上的关系" class="headerlink" title="基类和派生类在构造函数上的关系"></a><font color="indianred">基类和派生类在构造函数上的关系</font></h4><p>事实上，在创建派生类构造函数的时候会先调用基类的构造函数以确保完成所有与基类相关的初始化工作。</p>
<p>如我们在基类A中定义了变量A，在B中定义了b，那我们在创建对象的时候当然要把这个a也给初始化了，并且原则上是优先专门的事专门的人做，因此会调用基类构造方法去初始化a。</p>
<p>此时你可能会想，既然B把变量a给继承了过来，那不是可以在B中构造函数里面对a做初始化吗？确实可以，但是在你这么做之前，编译器还是会先执行A中的构造函数，然后再去执行B中的构造函数，也就是说你以为B是第一个对a做初始化的，但事实上B之后后来者，他只是把A做好的初始化给改了而已。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A();</span><br><span class="line">&#125;;</span><br><span class="line">A::A()<span class="comment">//第一步</span></span><br><span class="line">&#123;</span><br><span class="line">    a=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;createA&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;a，&quot;</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B(<span class="keyword">int</span> nameb);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printab</span><span class="params">()</span></span>&#123;<span class="comment">//第三步</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">B::B(<span class="keyword">int</span> nameb)<span class="comment">//第二步</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;a:&quot;</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//这里a的值还是A中初始化得到的1。</span></span><br><span class="line">    a=<span class="number">10</span>;<span class="comment">//🧠而这里B()将a的值改成了10</span></span><br><span class="line">    b=nameb;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;createB&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">B <span class="title">b</span><span class="params">(<span class="number">5</span>)</span></span>;<span class="comment">//a被A()赋予1，a被B()改成了10，b被B()赋予5</span></span><br><span class="line">b.p();<span class="comment">//因此打印出来a是10，b是5</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">createA</span></span><br><span class="line"><span class="comment">a，1</span></span><br><span class="line"><span class="comment">a:1</span></span><br><span class="line"><span class="comment">createB</span></span><br><span class="line"><span class="comment">10 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>好啦，下面看一个关于基类，派生类的构造函数及析构函数执行顺序的完整例子吧。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A(<span class="keyword">int</span> name);</span><br><span class="line"><span class="keyword">virtual</span>~A();</span><br><span class="line">&#125;;</span><br><span class="line">A::A(<span class="keyword">int</span> name)</span><br><span class="line">&#123;</span><br><span class="line">    a=name;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;createA&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A::~A()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Delete class APn&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">B(<span class="keyword">int</span> namea,<span class="keyword">int</span> nameb);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~B();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">B::B(<span class="keyword">int</span> namea,<span class="keyword">int</span> nameb):A(namea)</span><br><span class="line">&#123; <span class="comment">//A中为带参数的构造函数，因此我们需要调用这个构造参数，为其参数赋值</span></span><br><span class="line">    </span><br><span class="line">    b=nameb;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;createB&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B::~B()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Delete class BPn\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">B <span class="title">b</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">b.p();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">createA</span></span><br><span class="line"><span class="comment">createB</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">Delete class BPn</span></span><br><span class="line"><span class="comment">Delete class APn</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>所谓纯虚函数就是像这样<code>virtual ReturnType Function()= 0; </code>声明的函数，即没有具体实现的虚函数(记得写‘=0’)</p>
<p><font color="indianred">为什么要纯虚函数呢？</font></p>
<p>主要是为了更合理、更方便实现多态。试想一个动物基类可以派生出狮子，老虎等派生类，当时生成一个动物类的对象，这显然是不合理的，这时候就用到了纯虚函数：</p>
<ul>
<li>纯虚函数一般在基类中定义，写作<code>virtual ReturnType Function()= 0; </code></li>
<li>编译器要求，我们必须要在派生类中去重写出这个方法，以实现对态。</li>
<li>拥有纯虚函数的类称为抽象类，他不能生成对象。正如我们上面举的动物的例子一样。、</li>
</ul>
<p><font color="indianred">关于抽象类</font></p>
<ul>
<li><code>抽象类</code>与<code>带有纯虚函数的类</code>这两个说法是等价的。</li>
<li>抽象类只能作为基类来使用，试想如果在派生类中也声明了纯虚函数或是继承了基类的纯虚函数而不去重写，那么这个派生类也还是一个抽象类，也无法创造对象实例，那就没意义了。</li>
</ul>
<p><font color="indianred">虚函数和纯虚函数的关系</font></p>
<ul>
<li><p>纯虚函数当然也是虚函数了，只是不去实现而已。</p>
</li>
<li><p>而当子类重写父类的纯虚函数F之后，那子类中的这个F对于孙子类来说自然就变成了普通的虚函数。</p>
<p>然后孙子类也可以重写子类中的虚函数以实现需要的多态。</p>
</li>
</ul>
<h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h2><p>若一个变量需要在同一个工程中不同文件直接使用或修改，则需要将自变量做extern声明。只需将该变量在其中一个文件中定义，然后在另外一个文件中使用extern声明。（不要在文本类的编辑器如vs code中直接建两个文件夹去试，因为肯定不能直接去访问另一个文件夹中的文件的，去建个工程文件再试。当然把这四个文件写在同一个文件夹下是肯定没什么问题的。）</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/02/09/%E5%85%B3%E4%BA%8Ecpp%E7%B1%BB%E7%9A%84%E9%83%A8%E5%88%86%E7%82%B9/1.png" alt="1"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#main.hpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MAIN_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MAIN_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们在main.hpp中定义了一个int b，则在main.cpp中引入这个头文件即可直接访问和修改b了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;main.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    b=<span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 10</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#a.cpp文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> apple=<span class="number">7</span>;</span><br></pre></td></tr></table></figure>

<p>我们在a.cpp中定义了apple</p>
<p>如果我们想让他在main.cpp中被使用</p>
<p>于是用extern将其声明在a.hpp(即a.h)中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> a_hpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> a_hpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> apple;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>注意⚠️⚠️⚠️，我们并没有再定义一次apple，<code>extern int apple</code>只是一份声明，就像你对你定义的函数<code>int f()&#123;.....&#125;</code>的声明<code>int f();</code>一样。</p>
<p>这份声明的作用是说变量已经在其他源文件中定义,通知编译程序不必再为它开辟存储单元了。就是说这份声明不会再额外占用一份空间了。</p>
<p>那么我们只需在main.cpp中引入a.hpp即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;main.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;a.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    b=<span class="number">10</span>;</span><br><span class="line">    a=<span class="number">9</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;apple&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//9 10</span></span><br></pre></td></tr></table></figure>

<p>其实<code>extern int banana</code>的本意是声明外部变量，啥是外部变量呢？</p>
<p>在函数体外部定义的变量若没有使用static(静态局部变量)类型符都可以被叫做外部变量，这样定义了之后他的作用范围是当前程序的整个范围，这意味着所有函数都可以直接用它。（当然在单个文件中变量加不加static都可以作为当前程序的全局变量，而若是多个文件，则一个文件中的static是不允许在其他文件中申明的；如果非想把一个static变量定义在本cpp之外，那可以定义在一个头文件中，然后引入这个头文件就好啦。）</p>
<p>当某一个函数f去用banana的时候<code>extern int banana</code>即是说“f，我叫banana，在外部已经定义过了，所以你不用再定义一遍了，可以直接用我。”</p>
<p>所以声明格式 <code>extern 数据类型 外部变量banana</code>正确的理解应该是：</p>
<p>对于当前函数（或是文件）F来说，banana是一个外部变量，而我用extern去声明，只是要告诉F你想访问的这个变量是个外部变量早就有人定义过了你直接用吧。</p>
<p><font color="indianred">而不要理解成是extern关键字“创造”了一个“外部变量”，这样就本末倒置了。</font></p>
<p>最常见的就是我们在单个cpp文件中所说的定义在主函数外的全局变量，它对于主函数(或是其他任何函数)来说即为外部变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正常我们会这么写</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;main.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">int</span> c=<span class="number">15</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;........&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//15</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>其实我们完全可以把这个变量定义在最后边，然后在用到他的函数之前声明即可。声明位置选1234都可以，当然我们不能在5处声明，因为那在用到他的函数之后了：</p>
<p>(这看起来和函数在主函数之后定义，但在主函数之前声明差不多。)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;main.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> c;<span class="comment">//3</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    b=<span class="number">10</span>;</span><br><span class="line">    a=<span class="number">9</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;c;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5</span></span><br><span class="line"><span class="keyword">int</span> c=<span class="number">15</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>外部变量和局部变量是可以同名的，当定义了局部变量之后，下面再用这个变量用的就是局部变量了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;main.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;a.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> c=<span class="number">15</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> c=<span class="number">5200</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//15 5200</span></span><br></pre></td></tr></table></figure>

<p>总结：外部变量<code>banana</code>并不是像int,double那样是一种特定类型的变量，而是因为定义在当前范围之外而被称为外部变量，我们想在当前范围去访问/改变banana，就要在当前范围内用<code>extern int banana</code>来告诉当前范围banana已经定义好了直接用吧。为了程序的简洁有逻辑，我们往往把<code>extern int banana</code>这句话写在某个头文件<code>a.h</code>里，然后我们在当前范围引入这个头文件<code>#include &quot;a.h&quot;</code>之后就可以放心用啦。</p>
<p>对于多文件，当banana被引入当前文件a.cpp后，他就相当于a.cpp中的全局变量，因此不能在主函数外再定义一个全局变量（外部）banana，不过我们可以在main函数里面再定义一个banana，因为这是再定义局部变量，之前说过，外部变量和局部变量是可以同名的，只是会有覆盖效果罢了。</p>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>static 主要是为了解决如下问题：</p>
<p>我在函数中定义了一个局部变量count=0用count++来记录当前函数被运行了几次，</p>
<p>当我运行函数，编译器会为它在栈上分配空间，count=1</p>
<p>而当函数运行结束，这部分空间就会被释放掉。</p>
<p>那即使我在整个程序的生命周期内再次使用到这个函数，count又会被初始化为0，运行完了还是count=1，这显然没有达到我想要的效果。</p>
<p><font color="indiagreen">我们的理想变量是一个能够持续程序的整个生命周期，但作用范围又只限制于当前函数的变量。</font></p>
<p><font color="indianred">我们当然可以用全局变量来统计，但是我希望统计变量count只与当前函数有关，不会被其他东西给改掉，全局变量显然超出了这个范围。</font></p>
<p><font color="indianblue">static关键字</font>便很好的解决了这个问题。它就是那个“<font color="indiagreen">能够持续程序的整个生命周期，但作用范围又只限制于当前函数的变量</font>”。</p>
<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><ul>
<li><p>在一个cpp文件中，直接说全局变量一般默认指不加static修饰的全局变量。</p>
<p>所谓全局变量就是指可以作用在当前文件全部范围内的变量。并且全局变量还可以通过extern，作用在整个工程，被所有文件访问/操作。</p>
</li>
<li><p>而加了static的全局变量呢，再单个文件内来看和上面那种全局变量没什么区别，都是可以作用在当前文件所有范围内。</p>
<p>然而若从整个工程(这里指多文件)来看，static全局变量是不能被其他的文件访问的，即使用了extern也不好使，不允许这么干。</p>
</li>
</ul>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>const即constant的缩写，字面即不变的，也就是我们能用它来定义常量。</p>
<p>字面来理解，我们定义了常量，那么它就无法被改变了，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">       <span class="keyword">int</span> *p = (<span class="keyword">int</span> *)(&amp;a);</span><br><span class="line"></span><br><span class="line">       *p = <span class="number">1</span>;</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;a;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//1 3</span></span><br></pre></td></tr></table></figure>

<p>其实这事实上是不准确的，可以说不被改变只是因为C++的处理机制与编译器的优化而已，可以看一下上面的代码，p指针得到了a的地址，然后对a地址内的值进行了重新赋值，那从物理上来说a的值怎么可能不被改变呢？</p>
<p>我们来做一下尝试，将<code>const int a = 3;</code>改写为<code>volatile const int a = 3;</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">       <span class="keyword">int</span> *p = (<span class="keyword">int</span> *)(&amp;a);</span><br><span class="line"></span><br><span class="line">       *p = <span class="number">1</span>;</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;a;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//1 1</span></span><br></pre></td></tr></table></figure>

<p>前面输出结果中a的值没有变，是因为编译器根据const的机制做出了优化，让const向用户反馈的值没有改变，即它真的是“字面上的不变”。</p>
<p>volatile 关键字跟 const 对应相反，是易变的，容易改变的意思。所以不会被编译器优化，编译器也就不会改变对 a 变量的操作(这个操作即通过p指针改掉了a的值)。</p>
<p>所以可以看到我们看到的值与实际地址内的值是不一样的，这难免让人不爽。</p>
<p><font color="indianred">所以说<code>const变量不被改变</code>可以说是一场君子协定，它防不住恶意篡改。<br>因此平时写代码的时候尽量不要去对const变量去做什么更改赋值操作，这会造成它的表里不一。</font></p>
<p>事实上如果我们直接尝试做如下操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br></pre></td></tr></table></figure>

<p>编译器会提醒我们：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error: cannot initialize a variable of type &#x27;int *&#x27; with an rvalue of type</span><br><span class="line">      &#x27;const int *&#x27;</span><br><span class="line">      <span class="keyword">int</span> *p = &amp;a;</span><br></pre></td></tr></table></figure>

<p>而上面我们则是做了强制转换<code>(int *)(&amp;a)</code>。</p>
<p>将<code>const int *</code>转换成了<code>int *</code></p>
<p>解释完了这些，下面我们再说某个const变量不可改的时候，就按字面理解就行了，别再想它内部是不是被改了，反正我们看到的是不变的。</p>
<p>除了上面那样直接修饰一个变量，</p>
<p>下面来具体看const修饰指针有哪些用法：</p>
<blockquote>
<p><font color="chinese">先说一句，不要去记什么常量指针，指针常量啥的，还容易记错，只要看我下面写的红字就行了，知道const修饰的是啥就没问题了。</font></p>
</blockquote>
<ul>
<li><h3 id="const修饰指针指向的内容，则内容为不可变量"><a href="#const修饰指针指向的内容，则内容为不可变量" class="headerlink" title="const修饰指针指向的内容，则内容为不可变量"></a>const修饰指针指向的内容，则内容为不可变量</h3></li>
</ul>
<p>形如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;a；</span><br></pre></td></tr></table></figure>

<p>这是指，指针p指向的地址内的值(数值8)不能被修改，即我们不能去改变<code>*p</code>的值；</p>
<p><font color="indianred">其实简化来看这样写就是说<code>const</code>是在修饰<code>*p</code></font></p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;a；</span><br><span class="line">*p = <span class="number">5</span>;<span class="comment">//这样改便是错的</span></span><br></pre></td></tr></table></figure>

<p>但是我们却可以改变指针的指向，如再写道</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;a；</span><br><span class="line"><span class="keyword">int</span> b=<span class="number">5</span>;</span><br><span class="line">p = &amp;b;<span class="comment">//即我们现在把p指针指向了b的地址</span></span><br></pre></td></tr></table></figure>

<p>来一个完整的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *  p =&amp;a;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//3</span></span><br><span class="line">    p=&amp;b;<span class="comment">//即我们现在把p指针指向了b的地址</span></span><br><span class="line">  <span class="comment">//*p = b 错误</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//5</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//3 p已经脱离了a所在地址，与a不再有瓜葛，所以p改变不会再影响到a</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于指针指向可变，因此以下初始化方式都是对的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>错的</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = <span class="number">5</span>;</span><br><span class="line"><span class="number">2.</span>对的</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p;</span><br><span class="line"><span class="comment">//当然我们最好在定义时就赋值，这样未经初始化的指针是野指针，不安全，或者你可以初始化为nullptr</span></span><br><span class="line">p=&amp;a;</span><br><span class="line">最好是：</span><br><span class="line">  <span class="keyword">int</span> a=<span class="number">8</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *p =&amp;a;</span><br><span class="line"><span class="number">3.</span>对的</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *  p=&amp;a ;</span><br><span class="line">因为<span class="keyword">const</span> <span class="keyword">int</span> *  p本身指向地址内的数值即*p就是不可改变的，所以把常量赋给他也无所谓，没差别，想要改变把p指向其他地方就行了。记得只有<span class="keyword">const</span> type *型的变量，才能接收<span class="keyword">const</span> type *型的变量。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>下面这种是错的</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p;</span><br><span class="line">p=&amp;<span class="number">5</span>;<span class="comment">//cannot take the address of an rvalue of type &#x27;int&#x27; 我们无法去取数字常量的地址，当然const a=5还是可以取到的，即a的地址</span></span><br></pre></td></tr></table></figure>



<ul>
<li><h3 id="const-修饰指针，则指针为不可变量。"><a href="#const-修饰指针，则指针为不可变量。" class="headerlink" title="const 修饰指针，则指针为不可变量。"></a>const 修饰指针，则指针为不可变量。</h3></li>
</ul>
<p>形如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p = &amp;a;</span><br></pre></td></tr></table></figure>



<p><font color="indianred">其实简化来看这样写就是说<code>const</code>是在修饰<code>p</code></font></p>
<p>那么就是说我们不能再将指针p指向其他地方。</p>
<p>但是对于p现在指着的地址里面的值我们是可以改的。</p>
<p>由于指针指向不能变且需要指向明确的地址，我们就必须在定义的时候就制定指针指向，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>必须这样写</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p = &amp;a;</span><br><span class="line"><span class="number">2.</span>这样写便是错的</span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p = <span class="number">5</span>;<span class="comment">//cannot initialize a variable of type &#x27;int *const&#x27; with an rvalue of type &#x27;int&#x27;</span></span><br><span class="line">我们应该赋予的是一个地址而不是一个数</span><br><span class="line"><span class="number">3.</span>这样写也是错的</span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p = &amp;<span class="number">5</span>;<span class="comment">//cannot take the address of an rvalue of type &#x27;int&#x27;</span></span><br><span class="line">我们无法得到一个数字常量的地址，上面说过</span><br><span class="line"><span class="number">4.</span>这样也是错的</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p=&amp;a ;<span class="comment">//cannot initialize a variable of type &#x27;int *const&#x27; with an rvalue of type &#x27;const int *&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font color="indianred">记得，以后别轻易把const type *类型的变量赋给别的指针<br>只有const type *型的变量，才能接收const type *型的变量</font></p>
<p>下面看具体的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span>* <span class="keyword">const</span> p=&amp;a ;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//3</span></span><br><span class="line">    *p=<span class="number">5</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//5</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//5 因为p一直指向a的地址，所以修改的实际上就是a的内容</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h3 id="const-修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量"><a href="#const-修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量" class="headerlink" title="const 修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量"></a>const 修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量</h3></li>
</ul>
<p>形如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> p = &amp;a</span><br><span class="line"><span class="comment">//从上面的理解可以知道，这里也只有这一种赋值方法。</span></span><br></pre></td></tr></table></figure>

<p><font color="indianred">右边的const在修饰p这显而易见，所以p指针不能再指向其他地址；而左边的const则是在修饰一个<code>*const p</code>,但他本质上还是一个<code>*p</code>不是吗，所以说<code>*p</code>不能改，即p指针指向的那块地址里面的数不能改；所以说这玩意儿一通操作完之后，啥都不能改，起到的就是一个<code>const int a=5</code>的作用。。。</font></p>
<h3 id="const-作参数"><a href="#const-作参数" class="headerlink" title="const 作参数"></a>const 作参数</h3><p>跟上面类似理解即防止被篡改。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Helloa</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a;</span><br><span class="line">    <span class="comment">// ++a;  这就是是错误的，a不能被改变</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Helloa</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> * a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*a&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="comment">//*a = 9;//错的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们传递参数是自定义对象，那么如果直接传递的话上面说过还要调用到拷贝构造函数，如果传递的东西比较大比较浪费时间，所以还可以再配合上引用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span></span><br><span class="line">........</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Helloa</span><span class="params">(<span class="keyword">const</span> Animal &amp;a)</span></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;哈喽啊&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="const-修饰函数的返回值"><a href="#const-修饰函数的返回值" class="headerlink" title="const 修饰函数的返回值"></a>const 修饰函数的返回值</h3><ul>
<li>修饰内置类型(int ,double那些)。</li>
</ul>
<p>那修饰不修饰没啥区别，反正最后得到的都是一个值常量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">Helloa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>修饰自定义类型</li>
</ul>
<p>平时我们有时候会对一个类的对象作a=b的操作，但是如果a是返回值，那a便不能做左值了，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">.......</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">const</span> A <span class="title">Helloa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a；</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125; </span><br><span class="line">A b;</span><br><span class="line">那我们可以写：</span><br><span class="line">A c=Helloa();</span><br><span class="line">而不能写</span><br><span class="line">Helloa()=b;</span><br></pre></td></tr></table></figure>

<p>你可能有疑问，返回值应该是表达式(expression)不是本来就不能作为左值吗？其实不然，我们返回引用/指针类型（在类中）就行。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> &amp;<span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;f&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A b;</span><br><span class="line">    b.<span class="built_in">get</span>()=<span class="number">6</span>;<span class="comment">//其实我们得到的便是b.a的引用，然后将a改为了6</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;b.<span class="built_in">get</span>();<span class="comment">//6,</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">f</span></span><br><span class="line"><span class="comment">f</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当然了你不能这样：</span></span><br><span class="line"><span class="comment">int &amp;f()&#123;</span></span><br><span class="line"><span class="comment">    return 5;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">int main()&#123;</span></span><br><span class="line"><span class="comment">    f()=6;</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;f();</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">//因为单纯返回一个5他不是任何东西的引用，我们也不能将6赋给一个数值。</span></span><br><span class="line"><span class="comment">自然，指针也不行。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> *<span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;f&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> &amp;a;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A b;</span><br><span class="line">    *b.f()=<span class="number">6</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*b.f();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">f</span></span><br><span class="line"><span class="comment">f</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p>修饰的返回值为指针或者引用</p>
<ul>
<li><font color="indianred">指针</font>：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="title">F</span><span class="params">(<span class="keyword">int</span> *p)</span></span>&#123;<span class="comment">//返回一个值不可变的指针</span></span><br><span class="line">    *p=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">99</span>;</span><br><span class="line">    <span class="keyword">int</span> *p=&amp;a;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*F(p)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//10</span></span><br><span class="line">    <span class="keyword">int</span> * <span class="keyword">const</span>  q = F(p);<span class="comment">//错</span></span><br><span class="line">    <span class="keyword">int</span> * k = F(p);<span class="comment">//错</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>  这俩错的原因是：<br>    1.将 const int* 赋给了 int*;<br>    这与<br>    const int a=99;<br>    int <em>p = &a;<br>    是一样的错误<br>    因为此时的&amp;a 也是 const int</em><br>    原因在于：首先&amp;a是地址，而这块地址中的内容99不可以改变，所以就等效于const int*<br>    2.将 const int* 赋给了 int* const;</p>
<p>  <font color="indianred">所以记得，以后别轻易把const type *类型的变量赋给别的指针<br>只有const type *型的变量，才能接收const type *型的变量</font></p>
<ul>
<li><p>上面我们说过借助类和对象，我们可以把指针或引用型的返回值用作左值。那么如果是普通的函数呢？</p>
<blockquote>
<p>🍎🍎🍎</p>
<p>函数的返回类型决定了函数调用是否是左值。<br>调用一个返回引用的函数得到左值，调用其他返回类型得到右值。<br>于是我们可以像使用其他左值那样来使用“返回引用的函数”的调用<br>当然从常量的知识可以知道，这个返回值肯定不能是const型的，要不肯定不能为他赋值了。<br>即我们能为返回值为非常量引用的函数的结果赋值。</p>
<p>​                                                                                                                 ——参考自《C++ primer》p202</p>
</blockquote>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> &amp;<span class="title">F</span><span class="params">(<span class="keyword">int</span> &amp;a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">10</span>;</span><br><span class="line">    F(b)=<span class="number">89</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="indianred">你可以看到我们用了两个引用符号，为啥参数也要用引用呢？</font></p>
<p>这是因为<code>int &amp;F(int a)</code>中a作为函数参数保存在栈中，而函数运行一结束，那栈就清空了，这个a也就不在了，</p>
<p>另外局部对象在函数结束后也销毁了，局部指针在函数结束后也释放了，</p>
<p>所以说像函数参数以及在函数中定义的局部对象、局部指针千万别拿来返回，你都不知道会返回出个啥，而编译器也不会报错，最多警告你一下。</p>
<p>所以说不要以为是<code>&amp;a</code>让你做到左值功能的，这只是为了更靠谱，更安全。</p>
<p>不信你试试把F前面的引用符号&amp;给去掉，编译器就会甩个error给你：<font color="red">error: expression is not assignable</font></p>
<p>这红色看着可真难受～</p>
<h3 id="const-修饰函数"><a href="#const-修饰函数" class="headerlink" title="const 修饰函数"></a>const 修饰函数</h3><p>形如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int Helloa const&#123;</span><br><span class="line">.......</span><br><span class="line">&#125;&#x2F;&#x2F;一般用作类成员函数</span><br></pre></td></tr></table></figure>

<p><font color="indianred">注意哦，这里const释放函数名后面的，而不是放在前面的，放在前面是修饰返回值。<br>放在后面则表示这个函数是个只读函数，表示在这个函数的函数体内我们不能修改对象的数据成员，也不能调用非const函数。<br>为啥不能调用非const函数呢？<br>因为非const函数是可以修改数据成员的，而const规定不能修改数据成员，这不就矛盾了吗？所以在const成员函数内部只能调用cosnt函数。</font></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Helloa</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">            a=<span class="number">5</span>;<span class="comment">//那么这样写就是错的了。</span></span><br><span class="line">        &#125;</span><br><span class="line">  <span class="comment">//其实get函数用const修饰就很好</span></span><br><span class="line">  <span class="comment">//因为它要做的就是返回一个值</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;<span class="comment">//✅</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>写了const之后所有的数据成员在这个函数里就都改不了了，那我要是非想改怎么办呢，有啥办法可以让成员变量不受这个只读函数的限制呢？<code>mutable</code></p>
<p>我们可以使用<font color="indianred"> mutable 关键字</font>修饰这个成员，mutable 的意思也是易变的，容易改变的意思，被 mutable 关键字修饰的成员可以被修改。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">int</span> a;</span><br><span class="line">      <span class="keyword">mutable</span> <span class="keyword">int</span> b;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">Helloa</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">      ++a;<span class="comment">//❌错的，不能改</span></span><br><span class="line">      ++b;<span class="comment">//✅对的，加了mutable可以改了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>写个小总结：(下面用int指代各种type)</p>
<ul>
<li><p><font color="indianred">以后别*轻易把const int * 类型的变量赋给别的指针<br>只有const int *型的变量，才能接收const int *型的变量<br>const int * 可以接收int *<br>const int *可以接收int *const<br>const int *可以接收const int *    </font></p>
</li>
<li><p><font color="indianred">由于int * const指针的指向不能被改变，故只看在初始化的时候：<br>只可以接收int *和int * const<br></font></p>
</li>
<li><p><font color="indianred">int *只能接收int *和int * const<br></font></p>
</li>
</ul>
<h2 id="面向对象的一些特点"><a href="#面向对象的一些特点" class="headerlink" title="面向对象的一些特点"></a>面向对象的一些特点</h2><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a><font color="indianred">封装</font></h2><p>先说一下抽象，所谓抽象即我们提炼出某些事物的共同点，将其概括为一个类别，如有眼睛鼻子嘴巴，会跑动的是动物。</p>
<p>于是我们得到了一个类别Animal，它的属性有眼睛、鼻子、嘴巴，行为/功能有：奔跑。</p>
<p>老虎狮子都是这个动物类别的实例/对象。</p>
<p>当我们将这些事物抽象为了动物类，下面要做的便是封装。</p>
<p>所谓封装即我们将属性和行为等数据作为一个独立的整体，并且尽可能对外部隐藏内部实现细节，而只保留必要的接口对外开放，就是告诉类的使用者/用户你只需要知道可以用这个功能就行了，不需要知道他是怎么实现的，如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">robot</span>&#123;</span></span><br><span class="line">  <span class="keyword">private</span> :</span><br><span class="line">      <span class="keyword">double</span> <span class="built_in">height</span>;</span><br><span class="line">      <span class="keyword">bool</span> speaking_function;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">get_height</span><span class="params">()</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">bool</span> <span class="title">can_speaking</span><span class="params">()</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">Move</span><span class="params">()</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">Jump</span><span class="params">()</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">Do_Housework</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户买来机器人之后，只需要知道执行<code>Do_Housework()</code>就能让它做家务就行了，而无需知道这个功能是怎么实现的，因为这是设计者的事儿。</p>
<p>封装的好处就是让系统更安全，不至于随便一个孩子就来把这个机器人给改崩溃了。</p>
<h3 id="继承-2"><a href="#继承-2" class="headerlink" title="继承"></a><font color="indianred">继承</font></h3><p>我们用基类-派生类或是父类-子类来指代这种关系。</p>
<p>派生类可以继承一些这一类事物所共有的特性，如狮子继承自动物，他当然应该把眼睛鼻子嘴巴移动等东西给继承过来。</p>
<h3 id="多态-1"><a href="#多态-1" class="headerlink" title="多态"></a><font color="indianred">多态</font></h3><p>多态上面说过了，简单来说就是不同派生执行同一功能可以有不同效果。</p>
<p>如同样是继承自动物，老虎🐯的move()就是四蹄狂奔，而袋鼠🦘的move()则是向前跳跃。</p>
<p>封装和继承都为多态做了一定的准备工作。</p>
</div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="/2020/02/09/%E5%85%B3%E4%BA%8Ecpp%E7%B1%BB%E7%9A%84%E9%83%A8%E5%88%86%E7%82%B9/cover.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/03/12/linux1/"><img class="prev-cover" data-lazy-src="/img/cov2.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux-文件目录</div></div></a></div><div class="next-post pull-right"><a href="/2020/01/17/TCP-IP%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"><img class="next-cover" data-lazy-src="/2020/01/17/TCP-IP%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/cover.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">TCP/IP体系结构</div></div></a></div></nav></article></main><footer id="footer" style="background-image: url(/2020/02/09/%E5%85%B3%E4%BA%8Ecpp%E7%B1%BB%E7%9A%84%E9%83%A8%E5%88%86%E7%82%B9/top_img.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 江城子</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Thanks for visiting my <a target="_blank" rel="noopener" href="https://sosactwt.github.io/">page</a>!</div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  var script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>$(function () {
  $('span.katex-display').wrap('<div class="katex-wrap"></div>')
})</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>